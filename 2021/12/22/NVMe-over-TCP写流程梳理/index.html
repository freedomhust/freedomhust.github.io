<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"freedomhust.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="总结本文对NVMe over TCP的write和read命令下发流程进行了梳理">
<meta property="og:type" content="article">
<meta property="og:title" content="NVMe over TCP Write&#x2F;Read命令下发流程梳理">
<meta property="og:url" content="https://freedomhust.github.io/2021/12/22/NVMe-over-TCP%E5%86%99%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/index.html">
<meta property="og:site_name" content="熹微橙光">
<meta property="og:description" content="总结本文对NVMe over TCP的write和read命令下发流程进行了梳理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://freedomhust.github.io/2021/12/22/NVMe-over-TCP%E5%86%99%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/image-20211207105216923.png">
<meta property="article:published_time" content="2021-12-22T07:02:58.000Z">
<meta property="article:modified_time" content="2021-12-22T08:10:45.629Z">
<meta property="article:author" content="freedomhust">
<meta property="article:tag" content="NVMe over TCP">
<meta property="article:tag" content="femu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://freedomhust.github.io/2021/12/22/NVMe-over-TCP%E5%86%99%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/image-20211207105216923.png">

<link rel="canonical" href="https://freedomhust.github.io/2021/12/22/NVMe-over-TCP%E5%86%99%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>NVMe over TCP Write/Read命令下发流程梳理 | 熹微橙光</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">熹微橙光</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">休闲加菲猫</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    

  <a href="https://github.com/freedomhust" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://freedomhust.github.io/2021/12/22/NVMe-over-TCP%E5%86%99%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/freedomhust.jpg">
      <meta itemprop="name" content="freedomhust">
      <meta itemprop="description" content="个人技术总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="熹微橙光">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          NVMe over TCP Write/Read命令下发流程梳理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-22 15:02:58 / 修改时间：16:10:45" itemprop="dateCreated datePublished" datetime="2021-12-22T15:02:58+08:00">2021-12-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NVMe-over-TCP/" itemprop="url" rel="index"><span itemprop="name">NVMe over TCP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对NVMe over TCP的write和read命令下发流程进行了梳理</p>
<span id="more"></span>



<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h2><p>本文只针对Linux5.4.0版本的nvme内核模块源代码，使用命令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo nvme io-passthru /dev/nvme1n1 --opcode=<span class="number">1</span> --<span class="keyword">namespace</span>-id=<span class="number">1</span> --data-len=<span class="number">4096</span> --write --cdw10=<span class="number">5120</span> --cdw11=<span class="number">0</span> --cdw12=<span class="number">7</span> -s -i <span class="number">123.</span>txt</span><br><span class="line">sudo nvme io-passthru /dev/nvme1n1 --opcode=<span class="number">2</span> --<span class="keyword">namespace</span>-id=<span class="number">1</span> --data-len=<span class="number">4096</span> --write --cdw10=<span class="number">5120</span> --cdw11=<span class="number">0</span> --cdw12=<span class="number">7</span> -s -i <span class="number">456.</span>txt</span><br></pre></td></tr></table></figure>

<p>下发write和read命令，从nvme_ioctl函数开始对write进行一个梳理过程</p>
<h2 id="2-一些前置知识"><a href="#2-一些前置知识" class="headerlink" title="2. 一些前置知识"></a>2. 一些前置知识</h2><p>NVMe over TCP传输时，使用的时SGL而不是PRP</p>
<h2 id="3-host端与target端IO调用栈"><a href="#3-host端与target端IO调用栈" class="headerlink" title="3. host端与target端IO调用栈"></a>3. host端与target端IO调用栈</h2><p>我将所有函数都打了printk，write命令下发时，host端与target端的函数调用关系如下：</p>
<p>Host端：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[  <span class="number">627.604513</span>] nvme_dev_release</span><br><span class="line">[  <span class="number">709.055115</span>] *****************************nvme_ioctl</span><br><span class="line">[  <span class="number">709.055116</span>] nvme_get_ns_from_disk</span><br><span class="line">[  <span class="number">709.055117</span>] nvme_user_cmd</span><br><span class="line">[  <span class="number">709.055120</span>] nvme_passthru_start</span><br><span class="line">[  <span class="number">709.055120</span>] nvme_to_user_ptr</span><br><span class="line">[  <span class="number">709.055121</span>] nvme_to_user_ptr</span><br><span class="line">[  <span class="number">709.055121</span>] nvme_submit_user_cmd</span><br><span class="line">[  <span class="number">709.055122</span>] nvme_alloc_request</span><br><span class="line">[  <span class="number">709.055128</span>] nvme_tcp_queue_rq</span><br><span class="line">[  <span class="number">709.055128</span>] nvme_tcp_setup_cmd_pdu</span><br><span class="line">[  <span class="number">709.055129</span>] nvme_setup_cmd</span><br><span class="line">[  <span class="number">709.055129</span>] nvme_tcp_map_data</span><br><span class="line">[  <span class="number">709.055129</span>] nvme_tcp_set_sg_inline</span><br><span class="line">[  <span class="number">709.055131</span>] ##### nvme_tcp_queue_request</span><br><span class="line">[  <span class="number">709.055135</span>] *************************************nvme_tcp_io_work</span><br><span class="line">[  <span class="number">709.055136</span>] nvme_tcp_try_send</span><br><span class="line">[  <span class="number">709.055136</span>] nvme_tcp_fetch_request</span><br><span class="line">[  <span class="number">709.055136</span>] nvme_tcp_try_send_cmd_pdu</span><br><span class="line">[  <span class="number">709.055137</span>] nvme_tcp_has_inline_data</span><br><span class="line">[  <span class="number">709.055146</span>] nvme_tcp_init_iter</span><br><span class="line">[  <span class="number">709.055147</span>] nvme_tcp_has_inline_data</span><br><span class="line">[  <span class="number">709.055147</span>] nvme_tcp_try_send_data</span><br><span class="line">[  <span class="number">709.060325</span>] nvme_tcp_data_ready</span><br><span class="line">[  <span class="number">709.060327</span>] nvme_tcp_advance_req</span><br><span class="line">[  <span class="number">709.060328</span>] nvme_tcp_try_recv</span><br><span class="line">[  <span class="number">709.060328</span>] nvme_tcp_recv_skb</span><br><span class="line">[  <span class="number">709.060329</span>] nvme_tcp_recv_pdu</span><br><span class="line">[  <span class="number">709.060329</span>] nvme_tcp_init_recv_ctx</span><br><span class="line">[  <span class="number">709.060329</span>] nvme_tcp_handle_comp</span><br><span class="line">[  <span class="number">709.060330</span>] nvme_tcp_process_nvme_cqe</span><br><span class="line">[  <span class="number">709.060331</span>] nvme_complete_rq</span><br><span class="line">[  <span class="number">709.060331</span>] nvme_error_status</span><br><span class="line">[  <span class="number">709.060339</span>] nvme_tcp_try_send</span><br><span class="line">[  <span class="number">709.060339</span>] nvme_tcp_fetch_request</span><br><span class="line">[  <span class="number">709.060339</span>] nvme_tcp_try_recv</span><br><span class="line">[  <span class="number">709.060340</span>] *************************************nvme_tcp_io_work</span><br><span class="line">[  <span class="number">709.060341</span>] nvme_tcp_try_send</span><br><span class="line">[  <span class="number">709.060341</span>] nvme_tcp_fetch_request</span><br><span class="line">[  <span class="number">709.060341</span>] nvme_tcp_try_recv</span><br></pre></td></tr></table></figure>

<p>target端：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[  <span class="number">587.920537</span>] nvmet_tcp_data_ready</span><br><span class="line">[  <span class="number">587.920666</span>] nvmet_tcp_io_work</span><br><span class="line">[  <span class="number">587.920667</span>] ********************************nvmet_tcp_try_recv</span><br><span class="line">[  <span class="number">587.920667</span>] nvmet_tcp_try_recv_one</span><br><span class="line">[  <span class="number">587.920667</span>] nvmet_tcp_try_recv_pdu</span><br><span class="line">[  <span class="number">587.920672</span>] nvmet_tcp_done_recv_pdu</span><br><span class="line">[  <span class="number">587.920672</span>] nvmet_tcp_get_cmd</span><br><span class="line">[  <span class="number">587.920674</span>] nvmet_req_init</span><br><span class="line">[  <span class="number">587.920674</span>] nvmet_parse_io_cmd</span><br><span class="line">[  <span class="number">587.920675</span>] nvmet_bdev_parse_io_cmd</span><br><span class="line">[  <span class="number">587.920677</span>] nvmet_tcp_map_data</span><br><span class="line">[  <span class="number">587.920681</span>] nvmet_tcp_map_pdu_iovec</span><br><span class="line">[  <span class="number">587.920681</span>] nvmet_tcp_try_recv_data</span><br><span class="line">[  <span class="number">587.920683</span>] nvmet_req_execute</span><br><span class="line">[  <span class="number">587.920684</span>] nvmet_bdev_execute_rw</span><br><span class="line">[  <span class="number">587.920696</span>] nvme_setup_cmd</span><br><span class="line">[  <span class="number">587.920697</span>] nvme_setup_rw</span><br><span class="line">[  <span class="number">587.920711</span>] nvmet_prepare_receive_pdu</span><br><span class="line">[  <span class="number">587.920711</span>] nvmet_tcp_try_recv_one</span><br><span class="line">[  <span class="number">587.920711</span>] nvmet_tcp_try_recv_pdu</span><br><span class="line">[  <span class="number">587.920712</span>] nvmet_tcp_try_send</span><br><span class="line">[  <span class="number">587.920712</span>] nvmet_tcp_try_send_one</span><br><span class="line">[  <span class="number">587.920713</span>] nvmet_tcp_fetch_cmd</span><br><span class="line">[  <span class="number">587.920713</span>] nvmet_tcp_process_resp_list</span><br><span class="line">[  <span class="number">587.922352</span>] nvme_cleanup_cmd</span><br><span class="line">[  <span class="number">587.922353</span>] nvme_complete_rq</span><br><span class="line">[  <span class="number">587.922354</span>] nvme_error_status</span><br><span class="line">[  <span class="number">587.922356</span>] nvmet_bio_done</span><br><span class="line">[  <span class="number">587.922357</span>] blk_to_nvme_status</span><br><span class="line">[  <span class="number">587.922357</span>] nvmet_req_complete</span><br><span class="line">[  <span class="number">587.922358</span>] __nvmet_req_complete</span><br><span class="line">[  <span class="number">587.922359</span>] nvmet_tcp_queue_response</span><br><span class="line">[  <span class="number">587.922370</span>] nvmet_tcp_io_work</span><br><span class="line">[  <span class="number">587.922370</span>] ********************************nvmet_tcp_try_recv</span><br><span class="line">[  <span class="number">587.922371</span>] nvmet_tcp_try_recv_one</span><br><span class="line">[  <span class="number">587.922371</span>] nvmet_tcp_try_recv_pdu</span><br><span class="line">[  <span class="number">587.922373</span>] nvmet_tcp_try_send</span><br><span class="line">[  <span class="number">587.922374</span>] nvmet_tcp_try_send_one</span><br><span class="line">[  <span class="number">587.922374</span>] nvmet_tcp_fetch_cmd</span><br><span class="line">[  <span class="number">587.922374</span>] nvmet_tcp_process_resp_list</span><br><span class="line">[  <span class="number">587.922375</span>] nvmet_setup_response_pdu</span><br><span class="line">[  <span class="number">587.922375</span>] nvmet_try_send_response</span><br><span class="line">[  <span class="number">587.922430</span>] nvmet_tcp_try_send_one</span><br><span class="line">[  <span class="number">587.922431</span>] nvmet_tcp_fetch_cmd</span><br><span class="line">[  <span class="number">587.922431</span>] nvmet_tcp_process_resp_list</span><br></pre></td></tr></table></figure>



<p>read命令下发时，函数调用IO栈如下：</p>
<p>host端：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10119.754240</span>] *****************************nvme_ioctl</span><br><span class="line">[<span class="number">10119.754241</span>] nvme_get_ns_from_disk</span><br><span class="line">[<span class="number">10119.754246</span>] nvme_user_cmd</span><br><span class="line">[<span class="number">10119.754248</span>] nvme_passthru_start</span><br><span class="line">[<span class="number">10119.754249</span>] nvme_to_user_ptr</span><br><span class="line">[<span class="number">10119.754250</span>] nvme_to_user_ptr</span><br><span class="line">[<span class="number">10119.754250</span>] nvme_submit_user_cmd</span><br><span class="line">[<span class="number">10119.754251</span>] nvme_alloc_request</span><br><span class="line">[<span class="number">10119.754264</span>] nvme_tcp_queue_rq</span><br><span class="line">[<span class="number">10119.754265</span>] nvme_tcp_setup_cmd_pdu</span><br><span class="line">[<span class="number">10119.754265</span>] nvme_setup_cmd</span><br><span class="line">[<span class="number">10119.754268</span>] nvme_tcp_init_iter</span><br><span class="line">[<span class="number">10119.754269</span>] nvme_tcp_map_data</span><br><span class="line">[<span class="number">10119.754269</span>] nvme_tcp_set_sg_host_data</span><br><span class="line">[<span class="number">10119.754271</span>] ##### nvme_tcp_queue_request</span><br><span class="line">[<span class="number">10119.754278</span>] *************************************nvme_tcp_io_work</span><br><span class="line">[<span class="number">10119.754278</span>] nvme_tcp_try_send</span><br><span class="line">[<span class="number">10119.754278</span>] nvme_tcp_fetch_request</span><br><span class="line">[<span class="number">10119.754279</span>] nvme_tcp_try_send_cmd_pdu</span><br><span class="line">[<span class="number">10119.754279</span>] nvme_tcp_has_inline_data</span><br><span class="line">[<span class="number">10119.754363</span>] nvme_tcp_done_send_req</span><br><span class="line">[<span class="number">10119.754364</span>] nvme_tcp_has_inline_data</span><br><span class="line">[<span class="number">10119.754364</span>] nvme_tcp_try_recv</span><br><span class="line">[<span class="number">10119.754365</span>] nvme_tcp_try_send</span><br><span class="line">[<span class="number">10119.754365</span>] nvme_tcp_fetch_request</span><br><span class="line">[<span class="number">10119.754366</span>] nvme_tcp_try_recv</span><br><span class="line">[<span class="number">10119.760851</span>] nvme_tcp_data_ready</span><br><span class="line">[<span class="number">10119.760860</span>] nvme_tcp_data_ready</span><br><span class="line">[<span class="number">10119.760864</span>] *************************************nvme_tcp_io_work</span><br><span class="line">[<span class="number">10119.760865</span>] nvme_tcp_try_send</span><br><span class="line">[<span class="number">10119.760865</span>] nvme_tcp_fetch_request</span><br><span class="line">[<span class="number">10119.760866</span>] nvme_tcp_try_recv</span><br><span class="line">[<span class="number">10119.762412</span>] nvme_tcp_recv_skb</span><br><span class="line">[<span class="number">10119.762412</span>] nvme_tcp_recv_pdu</span><br><span class="line">[<span class="number">10119.762413</span>] nvme_tcp_handle_c2h_data</span><br><span class="line">[<span class="number">10119.762415</span>] nvme_tcp_recv_data</span><br><span class="line">[<span class="number">10119.762417</span>] nvme_tcp_init_recv_ctx</span><br><span class="line">[<span class="number">10119.762417</span>] nvme_tcp_recv_pdu</span><br><span class="line">[<span class="number">10119.762417</span>] nvme_tcp_init_recv_ctx</span><br><span class="line">[<span class="number">10119.762418</span>] nvme_tcp_handle_comp</span><br><span class="line">[<span class="number">10119.762418</span>] nvme_tcp_process_nvme_cqe</span><br><span class="line">[<span class="number">10119.762419</span>] nvme_complete_rq</span><br><span class="line">[<span class="number">10119.762419</span>] nvme_error_status</span><br><span class="line">[<span class="number">10119.762426</span>] nvme_tcp_try_send</span><br><span class="line">[<span class="number">10119.762426</span>] nvme_tcp_fetch_request</span><br><span class="line">[<span class="number">10119.762427</span>] nvme_tcp_try_recv</span><br></pre></td></tr></table></figure>

<p>target端：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10113.557551</span>] nvmet_tcp_io_work</span><br><span class="line">[<span class="number">10113.557552</span>] ********************************nvmet_tcp_try_recv</span><br><span class="line">[<span class="number">10113.557552</span>] nvmet_tcp_try_recv_one</span><br><span class="line">[<span class="number">10113.557553</span>] nvmet_tcp_try_recv_pdu</span><br><span class="line">[<span class="number">10113.557562</span>] nvmet_tcp_done_recv_pdu</span><br><span class="line">[<span class="number">10113.557562</span>] nvmet_tcp_get_cmd</span><br><span class="line">[<span class="number">10113.557567</span>] nvmet_req_init</span><br><span class="line">[<span class="number">10113.557567</span>] nvmet_parse_io_cmd</span><br><span class="line">[<span class="number">10113.557576</span>] nvmet_bdev_parse_io_cmd</span><br><span class="line">[<span class="number">10113.557579</span>] nvmet_tcp_map_data</span><br><span class="line">[<span class="number">10113.557583</span>] nvmet_req_execute</span><br><span class="line">[<span class="number">10113.557583</span>] nvmet_bdev_execute_rw</span><br><span class="line">[<span class="number">10113.557607</span>] nvme_setup_cmd</span><br><span class="line">[<span class="number">10113.557607</span>] nvme_setup_rw</span><br><span class="line">[<span class="number">10113.557635</span>] nvme_cleanup_cmd</span><br><span class="line">[<span class="number">10113.557636</span>] nvme_complete_rq</span><br><span class="line">[<span class="number">10113.557637</span>] nvme_error_status</span><br><span class="line">[<span class="number">10113.557637</span>] blk_mq_end_request</span><br><span class="line">[<span class="number">10113.557638</span>] nvmet_bio_done</span><br><span class="line">[<span class="number">10113.557638</span>] blk_to_nvme_status</span><br><span class="line">[<span class="number">10113.557639</span>] nvmet_req_complete</span><br><span class="line">[<span class="number">10113.557639</span>] __nvmet_req_complete</span><br><span class="line">[<span class="number">10113.557640</span>] nvmet_tcp_queue_response</span><br><span class="line">[<span class="number">10113.557645</span>] nvmet_prepare_receive_pdu</span><br><span class="line">[<span class="number">10113.557645</span>] nvmet_tcp_try_recv_one</span><br><span class="line">[<span class="number">10113.557646</span>] nvmet_tcp_try_recv_pdu</span><br><span class="line">[<span class="number">10113.557646</span>] nvmet_tcp_try_send</span><br><span class="line">[<span class="number">10113.557647</span>] nvmet_tcp_try_send_one</span><br><span class="line">[<span class="number">10113.557647</span>] nvmet_tcp_fetch_cmd</span><br><span class="line">[<span class="number">10113.557647</span>] nvmet_tcp_process_resp_list</span><br><span class="line">[<span class="number">10113.557648</span>] nvmet_setup_c2h_data_pdu</span><br><span class="line">[<span class="number">10113.557649</span>] nvmet_try_send_data_pdu</span><br><span class="line">[<span class="number">10113.557653</span>] nvmet_try_send_data</span><br><span class="line">[<span class="number">10113.557685</span>] nvmet_setup_response_pdu</span><br><span class="line">[<span class="number">10113.557685</span>] nvmet_try_send_response</span><br><span class="line">[<span class="number">10113.557686</span>] nvmet_tcp_put_cmd</span><br><span class="line">[<span class="number">10113.557687</span>] nvmet_tcp_try_send_one</span><br><span class="line">[<span class="number">10113.557687</span>] nvmet_tcp_fetch_cmd</span><br><span class="line">[<span class="number">10113.557687</span>] nvmet_tcp_process_resp_list</span><br><span class="line">[<span class="number">10113.557687</span>] llist_del_all=<span class="literal">NULL</span></span><br><span class="line">[<span class="number">10113.557688</span>] nvmet_tcp_io_work</span><br><span class="line">[<span class="number">10113.557688</span>] ********************************nvmet_tcp_try_recv</span><br><span class="line">[<span class="number">10113.557689</span>] nvmet_tcp_try_recv_one</span><br><span class="line">[<span class="number">10113.557689</span>] nvmet_tcp_try_recv_pdu</span><br><span class="line">[<span class="number">10113.557690</span>] nvmet_tcp_try_send</span><br><span class="line">[<span class="number">10113.557690</span>] nvmet_tcp_try_send_one</span><br><span class="line">[<span class="number">10113.557690</span>] nvmet_tcp_fetch_cmd</span><br><span class="line">[<span class="number">10113.557691</span>] nvmet_tcp_process_resp_list</span><br></pre></td></tr></table></figure>





<h2 id="4-Write命令函数调用关系图"><a href="#4-Write命令函数调用关系图" class="headerlink" title="4. Write命令函数调用关系图"></a>4. Write命令函数调用关系图</h2><p>![nvme over tcp write流程](NVMe-over-TCP写流程梳理/nvme over tcp write流程.png)</p>
<h2 id="5-Read命令函数调用关系图"><a href="#5-Read命令函数调用关系图" class="headerlink" title="5. Read命令函数调用关系图"></a>5. Read命令函数调用关系图</h2><p>![nvme over tcp read命令](NVMe-over-TCP写流程梳理/nvme over tcp read命令.png)</p>
<p>Write和Read命令下发的IO栈函数关系图如图所示，自己画的不是特别美观，下面就以Write命令为例将函数按照顺序从上到下，从左到右，按箭头的顺序进行分析，Read命令类似</p>
<h2 id="6-函数具体分析"><a href="#6-函数具体分析" class="headerlink" title="6. 函数具体分析"></a>6. 函数具体分析</h2><h3 id="host端"><a href="#host端" class="headerlink" title="host端"></a>host端</h3><h3 id="nvme-ioctl"><a href="#nvme-ioctl" class="headerlink" title="nvme_ioctl"></a>nvme_ioctl</h3><p>进入nvme_ioctl函数，传递由nvme-cli下发下来的写命令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nvme_ioctl</span><span class="params">(struct block_device *bdev, <span class="keyword">fmode_t</span> mode,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_ns_head</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">void</span> __user *argp = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_ns</span> *<span class="title">ns</span>;</span></span><br><span class="line">	<span class="keyword">int</span> srcu_idx, ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取nvme设备的namespace</span></span><br><span class="line">	ns = nvme_get_ns_from_disk(bdev-&gt;bd_disk, &amp;head, &amp;srcu_idx);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!ns))</span><br><span class="line">		<span class="keyword">return</span> -EWOULDBLOCK;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Handle ioctls that apply to the controller instead of the namespace</span></span><br><span class="line"><span class="comment">	 * seperately and drop the ns SRCU reference early.  This avoids a</span></span><br><span class="line"><span class="comment">	 * deadlock when deleting namespaces using the passthrough interface.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (is_ctrl_ioctl(cmd))&#123;</span><br><span class="line">        <span class="comment">// 如果是admin命令，进入该分支，提前释放ns</span></span><br><span class="line">		<span class="keyword">return</span> nvme_handle_ctrl_ioctl(ns, cmd, argp, head, srcu_idx);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> NVME_IOCTL_ID:</span><br><span class="line">		force_successful_syscall_return();</span><br><span class="line">		ret = ns-&gt;head-&gt;ns_id;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NVME_IOCTL_IO_CMD:</span><br><span class="line">        <span class="comment">// 如果是IO命令进入该分支</span></span><br><span class="line">		ret = nvme_user_cmd(ns-&gt;ctrl, ns, argp);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NVME_IOCTL_SUBMIT_IO:</span><br><span class="line">		ret = nvme_submit_io(ns, argp);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NVME_IOCTL_IO64_CMD:</span><br><span class="line">		ret = nvme_user_cmd64(ns-&gt;ctrl, ns, argp);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">if</span> (ns-&gt;ndev)</span><br><span class="line">			ret = nvme_nvm_ioctl(ns, cmd, arg);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ret = -ENOTTY;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nvme_put_ns_from_disk(head, srcu_idx);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于是写命令，所以会进入nvme_user_cmd函数中进行命令下发</p>
<h3 id="nvme-user-cmd"><a href="#nvme-user-cmd" class="headerlink" title="nvme_user_cmd"></a>nvme_user_cmd</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nvme_user_cmd</span><span class="params">(struct nvme_ctrl *ctrl, struct nvme_ns *ns,</span></span></span><br><span class="line"><span class="params"><span class="function">			struct nvme_passthru_cmd __user *ucmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_passthru_cmd</span> <span class="title">cmd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_command</span> <span class="title">c</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> timeout = <span class="number">0</span>;</span><br><span class="line">	u32 effects;</span><br><span class="line">	u64 result;</span><br><span class="line">	<span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!capable(CAP_SYS_ADMIN))</span><br><span class="line">		<span class="keyword">return</span> -EACCES;</span><br><span class="line">	<span class="comment">/*复制用户态已经设定好的cmd到cmd结构体中*/</span></span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;cmd, ucmd, <span class="keyword">sizeof</span>(cmd)))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	<span class="keyword">if</span> (cmd.flags)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*对nvme_command做一些初始化*/</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">	c.common.opcode = cmd.opcode;</span><br><span class="line">	c.common.flags = cmd.flags;</span><br><span class="line">	c.common.nsid = cpu_to_le32(cmd.nsid);</span><br><span class="line">	c.common.cdw2[<span class="number">0</span>] = cpu_to_le32(cmd.cdw2);</span><br><span class="line">	c.common.cdw2[<span class="number">1</span>] = cpu_to_le32(cmd.cdw3);</span><br><span class="line">	c.common.cdw10 = cpu_to_le32(cmd.cdw10);</span><br><span class="line">	c.common.cdw11 = cpu_to_le32(cmd.cdw11);</span><br><span class="line">	c.common.cdw12 = cpu_to_le32(cmd.cdw12);</span><br><span class="line">	c.common.cdw13 = cpu_to_le32(cmd.cdw13);</span><br><span class="line">	c.common.cdw14 = cpu_to_le32(cmd.cdw14);</span><br><span class="line">	c.common.cdw15 = cpu_to_le32(cmd.cdw15);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置超时时间*/</span></span><br><span class="line">	<span class="keyword">if</span> (cmd.timeout_ms)</span><br><span class="line">		timeout = msecs_to_jiffies(cmd.timeout_ms);</span><br><span class="line"></span><br><span class="line">	effects = nvme_passthru_start(ctrl, ns, cmd.opcode);</span><br><span class="line">    <span class="comment">/*下发nvme_command,因为是使用nvme_over_TCP，所以使用的是tcp queue，而不是通过pci queue*/</span></span><br><span class="line">	status = nvme_submit_user_cmd(ns ? ns-&gt;<span class="built_in">queue</span> : ctrl-&gt;admin_q, &amp;c,</span><br><span class="line">			nvme_to_user_ptr(cmd.addr), cmd.data_len,</span><br><span class="line">			nvme_to_user_ptr(cmd.metadata), cmd.metadata_len,</span><br><span class="line">			<span class="number">0</span>, &amp;result, timeout);</span><br><span class="line">	nvme_passthru_end(ctrl, effects);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (status &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*用于admin命令或者nvme over fabric命令回传结果信息*/</span></span><br><span class="line">		<span class="keyword">if</span> (put_user(result, &amp;ucmd-&gt;result))&#123;</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nvme-submit-user-cmd"><a href="#nvme-submit-user-cmd" class="headerlink" title="nvme_submit_user_cmd"></a>nvme_submit_user_cmd</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nvme_submit_user_cmd</span><span class="params">(struct request_queue *q,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct nvme_command *cmd, <span class="keyword">void</span> __user *ubuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">unsigned</span> bufflen, <span class="keyword">void</span> __user *meta_buffer, <span class="keyword">unsigned</span> meta_len,</span></span></span><br><span class="line"><span class="params"><span class="function">		u32 meta_seed, u64 *result, <span class="keyword">unsigned</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*NVMe 命令中，如果最低位为1 代表这是一个写数据命令，如果不为0 则是一个读数据命令*/</span></span><br><span class="line">	<span class="keyword">bool</span> write = nvme_is_write(cmd);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_ns</span> *<span class="title">ns</span> =</span> q-&gt;queuedata;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span> *<span class="title">disk</span> =</span> ns ? ns-&gt;disk : <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bio</span> *<span class="title">bio</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">void</span> *meta = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*创建一个request结构体供后续执行*/</span></span><br><span class="line">	req = nvme_alloc_request(q, cmd, <span class="number">0</span>, NVME_QID_ANY);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(req))&#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(req);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	req-&gt;timeout = timeout ? timeout : ADMIN_TIMEOUT;</span><br><span class="line">	nvme_req(req)-&gt;flags |= NVME_REQ_USERCMD;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ubuffer &amp;&amp; bufflen) &#123;</span><br><span class="line">		<span class="comment">/*完成用户态内存ubuffer和req-&gt;bio的映射，这样下发数据可以直接根据req-&gt;bio取得用户态的数据</span></span><br><span class="line"><span class="comment">		  或者读取数据时，直接通过该bio将数据读取到用户态的buffer中*/</span></span><br><span class="line">		ret = blk_rq_map_user(q, req, <span class="literal">NULL</span>, ubuffer, bufflen,</span><br><span class="line">				GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		bio = req-&gt;bio;</span><br><span class="line">		bio-&gt;bi_disk = disk;</span><br><span class="line">		<span class="keyword">if</span> (disk &amp;&amp; meta_buffer &amp;&amp; meta_len) &#123;</span><br><span class="line">			<span class="comment">/*加入元数据*/</span></span><br><span class="line">			meta = nvme_add_user_metadata(bio, meta_buffer, meta_len,</span><br><span class="line">					meta_seed, write);</span><br><span class="line">			<span class="keyword">if</span> (IS_ERR(meta)) &#123;</span><br><span class="line">				ret = PTR_ERR(meta);</span><br><span class="line">				<span class="keyword">goto</span> out_unmap;</span><br><span class="line">			&#125;</span><br><span class="line">			req-&gt;cmd_flags |= REQ_INTEGRITY;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*驱动层调用blk_execute_rq让块设备层执行request，由于是tcp queue，所以调用的是nvme_tcp_queue_rq函数*/</span></span><br><span class="line">	<span class="comment">/*insert a request into queue for execution*/</span></span><br><span class="line">	blk_execute_rq(req-&gt;q, disk, req, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (nvme_req(req)-&gt;flags &amp; NVME_REQ_CANCELLED)</span><br><span class="line">		ret = -EINTR;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ret = nvme_req(req)-&gt;status;</span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		*result = le64_to_cpu(nvme_req(req)-&gt;result.u64);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (meta &amp;&amp; !ret &amp;&amp; !write) &#123;</span><br><span class="line">        <span class="comment">/*如果是读命令且由metadata，将metadata写入到metabuffer中*/</span></span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(meta_buffer, meta, meta_len))</span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(meta);</span><br><span class="line"> out_unmap:</span><br><span class="line">	<span class="keyword">if</span> (bio)</span><br><span class="line">		blk_rq_unmap_user(bio); <span class="comment">/*取消用户态bio的映射关系*/</span></span><br><span class="line"> out:</span><br><span class="line"></span><br><span class="line">	blk_mq_free_request(req);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nvme-tcp-queue-rq"><a href="#nvme-tcp-queue-rq" class="headerlink" title="nvme_tcp_queue_rq"></a>nvme_tcp_queue_rq</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">blk_status_t</span> <span class="title">nvme_tcp_queue_rq</span><span class="params">(struct blk_mq_hw_ctx *hctx,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">const</span> struct blk_mq_queue_data *bd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_ns</span> *<span class="title">ns</span> =</span> hctx-&gt;<span class="built_in">queue</span>-&gt;queuedata;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_tcp_queue</span> *<span class="title">queue</span> =</span> hctx-&gt;driver_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">rq</span> =</span> bd-&gt;rq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_tcp_request</span> *<span class="title">req</span> =</span> blk_mq_rq_to_pdu(rq);</span><br><span class="line">	<span class="keyword">bool</span> queue_ready = test_bit(NVME_TCP_Q_LIVE, &amp;<span class="built_in">queue</span>-&gt;flags);</span><br><span class="line">	<span class="keyword">blk_status_t</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!nvmf_check_ready(&amp;<span class="built_in">queue</span>-&gt;ctrl-&gt;ctrl, rq, queue_ready))</span><br><span class="line">		<span class="keyword">return</span> nvmf_fail_nonready_command(&amp;<span class="built_in">queue</span>-&gt;ctrl-&gt;ctrl, rq);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*对将要发送的cmd pdu做一些初始化操作 包括分配cmd结构体，分配sgl*/</span></span><br><span class="line">	ret = nvme_tcp_setup_cmd_pdu(ns, rq);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(ret))</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*为request的执行做一些前置工作*/</span></span><br><span class="line">	blk_mq_start_request(rq);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*准备开始执行request*/</span></span><br><span class="line">	nvme_tcp_queue_request(req);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> BLK_STS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nvme-tcp-setup-cmd-pdu"><a href="#nvme-tcp-setup-cmd-pdu" class="headerlink" title="nvme_tcp_setup_cmd_pdu"></a>nvme_tcp_setup_cmd_pdu</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">blk_status_t</span> <span class="title">nvme_tcp_setup_cmd_pdu</span><span class="params">(struct nvme_ns *ns,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct request *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_tcp_request</span> *<span class="title">req</span> =</span> blk_mq_rq_to_pdu(rq);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_tcp_cmd_pdu</span> *<span class="title">pdu</span> =</span> req-&gt;pdu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_tcp_queue</span> *<span class="title">queue</span> =</span> req-&gt;<span class="built_in">queue</span>;</span><br><span class="line">	u8 hdgst = nvme_tcp_hdgst_len(<span class="built_in">queue</span>), ddgst = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">blk_status_t</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = nvme_setup_cmd(ns, rq, &amp;pdu-&gt;cmd);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*初始化nvme_tcp_request的一些状态，上面初始化的是request，而根据blk_mq_rq_to_pdu(rq)可知，两者是在物理空间上相邻的*/</span></span><br><span class="line">	req-&gt;state = NVME_TCP_SEND_CMD_PDU;</span><br><span class="line">	req-&gt;offset = <span class="number">0</span>;</span><br><span class="line">	req-&gt;data_sent = <span class="number">0</span>;</span><br><span class="line">	req-&gt;pdu_len = <span class="number">0</span>;</span><br><span class="line">	req-&gt;pdu_sent = <span class="number">0</span>;</span><br><span class="line">	req-&gt;data_len = blk_rq_nr_phys_segments(rq) ?</span><br><span class="line">				blk_rq_payload_bytes(rq) : <span class="number">0</span>; <span class="comment">/*要发送数据的长度，这里的长度由*/</span></span><br><span class="line">	req-&gt;curr_bio = rq-&gt;bio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*如果发送的是写命令而且req的data_len &lt;= 要发送的数据大小，则pdu_len赋值为data_len 这里可能是说，有data_len &lt; 要发送数据的情况，</span></span><br><span class="line"><span class="comment">      可能是用户在自定义参数赋值时出错了啥的*/</span></span><br><span class="line">	<span class="keyword">if</span> (rq_data_dir(rq) == WRITE &amp;&amp;</span><br><span class="line">	    req-&gt;data_len &lt;= nvme_tcp_inline_data_size(<span class="built_in">queue</span>))</span><br><span class="line">		req-&gt;pdu_len = req-&gt;data_len;</span><br><span class="line">    <span class="comment">/*如果curr_bio不为空，说明是读命令，则初始化iter，这个是用于后续接收到sock数据写到这里*/</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (req-&gt;curr_bio)</span><br><span class="line">		nvme_tcp_init_iter(req, READ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*对将要发送的pdu的hdr进行一些初始化操作*/</span></span><br><span class="line">	pdu-&gt;hdr.type = nvme_tcp_cmd;</span><br><span class="line">	pdu-&gt;hdr.flags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;hdr_digest)</span><br><span class="line">		pdu-&gt;hdr.flags |= NVME_TCP_F_HDGST;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;data_digest &amp;&amp; req-&gt;pdu_len) &#123;</span><br><span class="line">		pdu-&gt;hdr.flags |= NVME_TCP_F_DDGST;</span><br><span class="line">		ddgst = nvme_tcp_ddgst_len(<span class="built_in">queue</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pdu-&gt;hdr.hlen = <span class="keyword">sizeof</span>(*pdu);</span><br><span class="line">	pdu-&gt;hdr.pdo = req-&gt;pdu_len ? pdu-&gt;hdr.hlen + hdgst : <span class="number">0</span>;</span><br><span class="line">	pdu-&gt;hdr.plen =</span><br><span class="line">		cpu_to_le32(pdu-&gt;hdr.hlen + hdgst + req-&gt;pdu_len + ddgst);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*初始化SGL，但不知道里面的addr中0和icdoff的意义*/</span></span><br><span class="line">	ret = nvme_tcp_map_data(<span class="built_in">queue</span>, rq);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(ret)) &#123;</span><br><span class="line">		nvme_cleanup_cmd(rq);</span><br><span class="line">		dev_err(<span class="built_in">queue</span>-&gt;ctrl-&gt;ctrl.device,</span><br><span class="line">			<span class="string">&quot;Failed to map data (%d)\n&quot;</span>, ret);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nvme-tcp-queue-request"><a href="#nvme-tcp-queue-request" class="headerlink" title="nvme_tcp_queue_request"></a>nvme_tcp_queue_request</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">nvme_tcp_queue_request</span><span class="params">(struct nvme_tcp_request *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk(<span class="string">&quot;##### nvme_tcp_queue_request&quot;</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_tcp_queue</span> *<span class="title">queue</span> =</span> req-&gt;<span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;<span class="built_in">queue</span>-&gt;lock);</span><br><span class="line">	list_add_tail(&amp;req-&gt;entry, &amp;<span class="built_in">queue</span>-&gt;send_list);</span><br><span class="line">	spin_unlock(&amp;<span class="built_in">queue</span>-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*执行io_work函数*/</span></span><br><span class="line">	queue_work_on(<span class="built_in">queue</span>-&gt;io_cpu, nvme_tcp_wq, &amp;<span class="built_in">queue</span>-&gt;io_work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nvme-tcp-io-work"><a href="#nvme-tcp-io-work" class="headerlink" title="nvme_tcp_io_work"></a>nvme_tcp_io_work</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nvme_tcp_io_work</span><span class="params">(struct work_struct *w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_tcp_queue</span> *<span class="title">queue</span> =</span></span><br><span class="line">		container_of(w, struct nvme_tcp_queue, io_work);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> deadline = jiffies + msecs_to_jiffies(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">bool</span> pending = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*利用TCP/IP发送PDU*/</span></span><br><span class="line">		result = nvme_tcp_try_send(<span class="built_in">queue</span>);</span><br><span class="line">		<span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			pending = <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(result &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">			dev_err(<span class="built_in">queue</span>-&gt;ctrl-&gt;ctrl.device,</span><br><span class="line">				<span class="string">&quot;failed to send request %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Fail the request unless peer closed the connection,</span></span><br><span class="line"><span class="comment">			 * in which case error recovery flow will complete all.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> ((result != -EPIPE) &amp;&amp; (result != -ECONNRESET))&#123;</span><br><span class="line">				nvme_tcp_fail_request(<span class="built_in">queue</span>-&gt;request);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			nvme_tcp_done_send_req(<span class="built_in">queue</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*接收cqe*/</span></span><br><span class="line">		result = nvme_tcp_try_recv(<span class="built_in">queue</span>);</span><br><span class="line">		<span class="keyword">if</span> (result &gt; <span class="number">0</span>)</span><br><span class="line">			pending = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!pending)&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125; <span class="keyword">while</span> (!time_after(jiffies, deadline)); <span class="comment">/* quota is exhausted */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	queue_work_on(<span class="built_in">queue</span>-&gt;io_cpu, nvme_tcp_wq, &amp;<span class="built_in">queue</span>-&gt;io_work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nvme-tcp-try-send"><a href="#nvme-tcp-try-send" class="headerlink" title="nvme_tcp_try_send"></a>nvme_tcp_try_send</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nvme_tcp_try_send</span><span class="params">(struct nvme_tcp_queue *<span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_tcp_request</span> *<span class="title">req</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">queue</span>-&gt;request) &#123;</span><br><span class="line">        <span class="comment">/*从queue中取出request执行，如果queue中没有request，则不执行，直接返回*/</span></span><br><span class="line">		<span class="built_in">queue</span>-&gt;request = nvme_tcp_fetch_request(<span class="built_in">queue</span>);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">queue</span>-&gt;request)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	req = <span class="built_in">queue</span>-&gt;request;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*注意这里不是if else，而是4个if，req_&gt;state的值会在各个send函数中改变，write命令在这里的执行顺序是，</span></span><br><span class="line"><span class="comment">    	nvme_tcp_try_send_cmd_pdu-&gt;nvme_tcp_try_send_data，无DDGST*/</span></span><br><span class="line">	<span class="keyword">if</span> (req-&gt;state == NVME_TCP_SEND_CMD_PDU) &#123;</span><br><span class="line">		ret = nvme_tcp_try_send_cmd_pdu(req);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> done;</span><br><span class="line">		<span class="keyword">if</span> (!nvme_tcp_has_inline_data(req))&#123;</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (req-&gt;state == NVME_TCP_SEND_H2C_PDU) &#123;</span><br><span class="line">		ret = nvme_tcp_try_send_data_pdu(req);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (req-&gt;state == NVME_TCP_SEND_DATA) &#123;</span><br><span class="line">		ret = nvme_tcp_try_send_data(req);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (req-&gt;state == NVME_TCP_SEND_DDGST)</span><br><span class="line">		ret = nvme_tcp_try_send_ddgst(req);</span><br><span class="line">done:</span><br><span class="line">	<span class="keyword">if</span> (ret == -EAGAIN)</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nvme-tcp-try-send-cmd-pdu"><a href="#nvme-tcp-try-send-cmd-pdu" class="headerlink" title="nvme_tcp_try_send_cmd_pdu"></a>nvme_tcp_try_send_cmd_pdu</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nvme_tcp_try_send_cmd_pdu</span><span class="params">(struct nvme_tcp_request *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_tcp_queue</span> *<span class="title">queue</span> =</span> req-&gt;<span class="built_in">queue</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_tcp_cmd_pdu</span> *<span class="title">pdu</span> =</span> req-&gt;pdu;</span><br><span class="line">	<span class="keyword">bool</span> inline_data = nvme_tcp_has_inline_data(req);</span><br><span class="line">	<span class="keyword">int</span> flags = MSG_DONTWAIT | (inline_data ? MSG_MORE : MSG_EOR);</span><br><span class="line">	u8 hdgst = nvme_tcp_hdgst_len(<span class="built_in">queue</span>);</span><br><span class="line">	<span class="keyword">int</span> len = <span class="keyword">sizeof</span>(*pdu) + hdgst - req-&gt;offset;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*如果有摘要，则先处理摘要*/</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;hdr_digest &amp;&amp; !req-&gt;offset)</span><br><span class="line">		nvme_tcp_hdgst(<span class="built_in">queue</span>-&gt;snd_hash, pdu, <span class="keyword">sizeof</span>(*pdu));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*发送PDU*/</span></span><br><span class="line">	ret = kernel_sendpage(<span class="built_in">queue</span>-&gt;sock, virt_to_page(pdu),</span><br><span class="line">			offset_in_page(pdu) + req-&gt;offset, len,  flags);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(ret &lt;= <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	len -= ret;</span><br><span class="line">	<span class="keyword">if</span> (!len) &#123;</span><br><span class="line">		<span class="keyword">if</span> (inline_data) &#123;</span><br><span class="line">            <span class="comment">/*如果有data要发送，则将state置为NVME_TCP_SEND_DATA，这样就可以进入nvme_tcp_try_send_data函数了*/</span></span><br><span class="line">			req-&gt;state = NVME_TCP_SEND_DATA;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;data_digest)</span><br><span class="line">				crypto_ahash_init(<span class="built_in">queue</span>-&gt;snd_hash);</span><br><span class="line">            <span class="comment">/*对iter进行初始化，不过不知道这个iter和SGL什么关系*/</span></span><br><span class="line">			nvme_tcp_init_iter(req, WRITE);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			nvme_tcp_done_send_req(<span class="built_in">queue</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="comment">/*累加offset*/</span></span><br><span class="line">	req-&gt;offset += ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nvme-tcp-try-send-data"><a href="#nvme-tcp-try-send-data" class="headerlink" title="nvme_tcp_try_send_data"></a>nvme_tcp_try_send_data</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nvme_tcp_try_send_data</span><span class="params">(struct nvme_tcp_request *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_tcp_queue</span> *<span class="title">queue</span> =</span> req-&gt;<span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> nvme_tcp_req_cur_page(req);</span><br><span class="line">		<span class="keyword">size_t</span> offset = nvme_tcp_req_cur_offset(req);</span><br><span class="line">		<span class="keyword">size_t</span> len = nvme_tcp_req_cur_length(req);</span><br><span class="line">		<span class="keyword">bool</span> last = nvme_tcp_pdu_last_send(req, len);</span><br><span class="line">		<span class="keyword">int</span> ret, flags = MSG_DONTWAIT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*如果是最后的数据发送了而且没有data摘要，flag加上EOR，否则是MORE*/</span></span><br><span class="line">		<span class="keyword">if</span> (last &amp;&amp; !<span class="built_in">queue</span>-&gt;data_digest)</span><br><span class="line">			flags |= MSG_EOR;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			flags |= MSG_MORE;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (sendpage_ok(page)) &#123;</span><br><span class="line">			ret = kernel_sendpage(<span class="built_in">queue</span>-&gt;sock, page, offset, len,</span><br><span class="line">					flags);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ret = sock_no_sendpage(<span class="built_in">queue</span>-&gt;sock, page, offset, len,</span><br><span class="line">					flags);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*计算偏移值，便于继续发送下一个BIO的数据，所以，senddata其实发送的是BIO的数据？</span></span><br><span class="line"><span class="comment">        	如果不连续的话，则发送完一个BIO再发送下一个BIO的数据*/</span></span><br><span class="line">		nvme_tcp_advance_req(req, ret);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;data_digest)</span><br><span class="line">			nvme_tcp_ddgst_update(<span class="built_in">queue</span>-&gt;snd_hash, page,</span><br><span class="line">					offset, ret);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* fully successful last write*/</span></span><br><span class="line">		<span class="keyword">if</span> (last &amp;&amp; ret == len) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;data_digest) &#123;</span><br><span class="line">				nvme_tcp_ddgst_final(<span class="built_in">queue</span>-&gt;snd_hash,</span><br><span class="line">					&amp;req-&gt;ddgst);</span><br><span class="line">				req-&gt;state = NVME_TCP_SEND_DDGST;</span><br><span class="line">				req-&gt;offset = <span class="number">0</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/*发送全部结束*/</span></span><br><span class="line">				nvme_tcp_done_send_req(<span class="built_in">queue</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/12/22/NVMe-over-TCP%E5%86%99%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/image-20211207105216923.png" class="" title="image-20211207105216923">



<p>至此，Host端的数据发送已经结束（无DIGIST），之后按时间顺序转到Target端执行相关函数</p>
<h3 id="target端"><a href="#target端" class="headerlink" title="target端"></a>target端</h3><h3 id="nvmet-tcp-io-work"><a href="#nvmet-tcp-io-work" class="headerlink" title="nvmet_tcp_io_work"></a>nvmet_tcp_io_work</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nvmet_tcp_io_work</span><span class="params">(struct work_struct *w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvmet_tcp_queue</span> *<span class="title">queue</span> =</span></span><br><span class="line">		container_of(w, struct nvmet_tcp_queue, io_work);</span><br><span class="line">	<span class="keyword">bool</span> pending;</span><br><span class="line">	<span class="keyword">int</span> ret, ops = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		pending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*与host端的io_work不一样，target端的io_work最开始是尝试接收*/</span></span><br><span class="line">		ret = nvmet_tcp_try_recv(<span class="built_in">queue</span>, NVMET_TCP_RECV_BUDGET, &amp;ops);</span><br><span class="line">		<span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			pending = <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ret == -EPIPE || ret == -ECONNRESET)</span><br><span class="line">				kernel_sock_shutdown(<span class="built_in">queue</span>-&gt;sock, SHUT_RDWR);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				nvmet_tcp_fatal_error(<span class="built_in">queue</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*接收完毕后，开始根据接收到的数据向主机端发送cmd，可能是R2T，可能是cqe*/</span></span><br><span class="line">		ret = nvmet_tcp_try_send(<span class="built_in">queue</span>, NVMET_TCP_SEND_BUDGET, &amp;ops);</span><br><span class="line">		<span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* transmitted message/data */</span></span><br><span class="line">			pending = <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ret == -EPIPE || ret == -ECONNRESET)</span><br><span class="line">				kernel_sock_shutdown(<span class="built_in">queue</span>-&gt;sock, SHUT_RDWR);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				nvmet_tcp_fatal_error(<span class="built_in">queue</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (pending &amp;&amp; ops &lt; NVMET_TCP_IO_WORK_BUDGET);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We exahusted our budget, requeue our selves</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (pending)</span><br><span class="line">		queue_work_on(<span class="built_in">queue</span>-&gt;cpu, nvmet_tcp_wq, &amp;<span class="built_in">queue</span>-&gt;io_work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nvmet-tcp-try-recv"><a href="#nvmet-tcp-try-recv" class="headerlink" title="nvmet_tcp_try_recv"></a>nvmet_tcp_try_recv</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nvmet_tcp_try_recv</span><span class="params">(struct nvmet_tcp_queue *<span class="built_in">queue</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">int</span> budget, <span class="keyword">int</span> *recvs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; budget; i++) &#123;</span><br><span class="line">        <span class="comment">/*尝试从sock接收数据*/</span></span><br><span class="line">		ret = nvmet_tcp_try_recv_one(<span class="built_in">queue</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		(*recvs)++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nvmet-tcp-try-recv-one"><a href="#nvmet-tcp-try-recv-one" class="headerlink" title="nvmet_tcp_try_recv_one"></a>nvmet_tcp_try_recv_one</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nvmet_tcp_try_recv_one</span><span class="params">(struct nvmet_tcp_queue *<span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(<span class="built_in">queue</span>-&gt;rcv_state == NVMET_TCP_RECV_ERR))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*根据queue-&gt;rcv_state来进入不同的分支，write的state变化是，NVMET_TCP_RECV_PDU-&gt;nvmet_tcp_try_recv_data</span></span><br><span class="line"><span class="comment">    	queue-&gt;rcv_state在队列最开始初始化时，状态是NVMET_TCP_RECV_PDU*/</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;rcv_state == NVMET_TCP_RECV_PDU) &#123;</span><br><span class="line">		result = nvmet_tcp_try_recv_pdu(<span class="built_in">queue</span>);</span><br><span class="line">		<span class="keyword">if</span> (result != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> done_recv;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;rcv_state == NVMET_TCP_RECV_DATA) &#123;</span><br><span class="line">		result = nvmet_tcp_try_recv_data(<span class="built_in">queue</span>);</span><br><span class="line">		<span class="keyword">if</span> (result != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> done_recv;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;rcv_state == NVMET_TCP_RECV_DDGST) &#123;</span><br><span class="line">		result = nvmet_tcp_try_recv_ddgst(<span class="built_in">queue</span>);</span><br><span class="line">		<span class="keyword">if</span> (result != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> done_recv;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">done_recv:</span><br><span class="line">	<span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (result == -EAGAIN)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nvmet-tcp-try-recv-pdu"><a href="#nvmet-tcp-try-recv-pdu" class="headerlink" title="nvmet_tcp_try_recv_pdu"></a>nvmet_tcp_try_recv_pdu</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nvmet_tcp_try_recv_pdu</span><span class="params">(struct nvmet_tcp_queue *<span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_tcp_hdr</span> *<span class="title">hdr</span> =</span> &amp;<span class="built_in">queue</span>-&gt;pdu.cmd.hdr;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvec</span> <span class="title">iov</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span> =</span> &#123; .msg_flags = MSG_DONTWAIT &#125;;</span><br><span class="line"></span><br><span class="line">recv:</span><br><span class="line">    <span class="comment">/*建立iov与queue-&gt;pdu的映射关系，这样sock接收到的数据可以直接写到queue-&gt;pdu中进行访问</span></span><br><span class="line"><span class="comment">    	queue-&gt;left初始值为sizeof(struct nvme_tcp_hdr)*/</span></span><br><span class="line">	iov.iov_base = (<span class="keyword">void</span> *)&amp;<span class="built_in">queue</span>-&gt;pdu + <span class="built_in">queue</span>-&gt;offset;</span><br><span class="line">	iov.iov_len = <span class="built_in">queue</span>-&gt;left初始值为;</span><br><span class="line">	len = kernel_recvmsg(<span class="built_in">queue</span>-&gt;sock, &amp;msg, &amp;iov, <span class="number">1</span>,</span><br><span class="line">			iov.iov_len, msg.msg_flags);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(len &lt; <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> len;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">queue</span>-&gt;offset += len;</span><br><span class="line">	<span class="built_in">queue</span>-&gt;left -= len;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;left)</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;offset == <span class="keyword">sizeof</span>(struct nvme_tcp_hdr)) &#123;</span><br><span class="line">		u8 hdgst = nvmet_tcp_hdgst_len(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!nvmet_tcp_pdu_valid(hdr-&gt;type))) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;unexpected pdu type %d\n&quot;</span>, hdr-&gt;type);</span><br><span class="line">			nvmet_tcp_fatal_error(<span class="built_in">queue</span>);</span><br><span class="line">			<span class="keyword">return</span> -EIO;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(hdr-&gt;hlen != nvmet_tcp_pdu_size(hdr-&gt;type))) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;pdu %d bad hlen %d\n&quot;</span>, hdr-&gt;type, hdr-&gt;hlen);</span><br><span class="line">			<span class="keyword">return</span> -EIO;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">queue</span>-&gt;left = hdr-&gt;hlen - <span class="built_in">queue</span>-&gt;offset + hdgst;</span><br><span class="line">		<span class="keyword">goto</span> recv;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;hdr_digest &amp;&amp;</span><br><span class="line">	    nvmet_tcp_verify_hdgst(<span class="built_in">queue</span>, &amp;<span class="built_in">queue</span>-&gt;pdu, <span class="built_in">queue</span>-&gt;offset)) &#123;</span><br><span class="line">		nvmet_tcp_fatal_error(<span class="built_in">queue</span>); <span class="comment">/* fatal */</span></span><br><span class="line">		<span class="keyword">return</span> -EPROTO;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;data_digest &amp;&amp;</span><br><span class="line">	    nvmet_tcp_check_ddgst(<span class="built_in">queue</span>, &amp;<span class="built_in">queue</span>-&gt;pdu)) &#123;</span><br><span class="line">		nvmet_tcp_fatal_error(<span class="built_in">queue</span>); <span class="comment">/* fatal */</span></span><br><span class="line">		<span class="keyword">return</span> -EPROTO;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*结束接收PDU的工作，接下来根据接受到的PDU进行处理*/</span></span><br><span class="line">	<span class="keyword">return</span> nvmet_tcp_done_recv_pdu(<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nvmet-tcp-done-recv-pdu"><a href="#nvmet-tcp-done-recv-pdu" class="headerlink" title="nvmet_tcp_done_recv_pdu"></a>nvmet_tcp_done_recv_pdu</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nvmet_tcp_done_recv_pdu</span><span class="params">(struct nvmet_tcp_queue *<span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_tcp_hdr</span> *<span class="title">hdr</span> =</span> &amp;<span class="built_in">queue</span>-&gt;pdu.cmd.hdr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_command</span> *<span class="title">nvme_cmd</span> =</span> &amp;<span class="built_in">queue</span>-&gt;pdu.cmd.cmd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvmet_req</span> *<span class="title">req</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(<span class="built_in">queue</span>-&gt;state == NVMET_TCP_Q_CONNECTING)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (hdr-&gt;type != nvme_tcp_icreq) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;unexpected pdu type (%d) before icreq\n&quot;</span>,</span><br><span class="line">				hdr-&gt;type);</span><br><span class="line">			nvmet_tcp_fatal_error(<span class="built_in">queue</span>);</span><br><span class="line">			<span class="keyword">return</span> -EPROTO;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> nvmet_tcp_handle_icreq(<span class="built_in">queue</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hdr-&gt;type == nvme_tcp_h2c_data) &#123;</span><br><span class="line">		ret = nvmet_tcp_handle_h2c_data_pdu(<span class="built_in">queue</span>);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(ret))</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*新建nvmet_tcp_cmd结构体并做一些初始化操作*/</span></span><br><span class="line">	<span class="built_in">queue</span>-&gt;cmd = nvmet_tcp_get_cmd(<span class="built_in">queue</span>);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!<span class="built_in">queue</span>-&gt;cmd)) &#123;</span><br><span class="line">		<span class="comment">/* This should never happen */</span></span><br><span class="line">		pr_err(<span class="string">&quot;queue %d: out of commands (%d) send_list_len: %d, opcode: %d&quot;</span>,</span><br><span class="line">			<span class="built_in">queue</span>-&gt;idx, <span class="built_in">queue</span>-&gt;nr_cmds, <span class="built_in">queue</span>-&gt;send_list_len,</span><br><span class="line">			nvme_cmd-&gt;common.opcode);</span><br><span class="line">		nvmet_tcp_fatal_error(<span class="built_in">queue</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	req = &amp;<span class="built_in">queue</span>-&gt;cmd-&gt;req;</span><br><span class="line">    <span class="comment">/*复制传递过来的nvme_cmd到queue-&gt;cmd-&gt;req-&gt;cmd中去*/</span></span><br><span class="line">	<span class="built_in">memcpy</span>(req-&gt;cmd, nvme_cmd, <span class="keyword">sizeof</span>(*nvme_cmd));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*对nvmet_req做一些初始化操作，包括根据opcode绑定执行函数，绑定sqe，cqe等*/</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!nvmet_req_init(req, &amp;<span class="built_in">queue</span>-&gt;nvme_cq,</span><br><span class="line">			&amp;<span class="built_in">queue</span>-&gt;nvme_sq, &amp;nvmet_tcp_ops))) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;failed cmd %p id %d opcode %d, data_len: %d\n&quot;</span>,</span><br><span class="line">			req-&gt;cmd, req-&gt;cmd-&gt;common.command_id,</span><br><span class="line">			req-&gt;cmd-&gt;common.opcode,</span><br><span class="line">			le32_to_cpu(req-&gt;cmd-&gt;common.dptr.sgl.length));</span><br><span class="line"></span><br><span class="line">		nvmet_tcp_handle_req_failure(<span class="built_in">queue</span>, <span class="built_in">queue</span>-&gt;cmd, req);</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*申请SGL数组，申请iov数组*/</span></span><br><span class="line">	ret = nvmet_tcp_map_data(<span class="built_in">queue</span>-&gt;cmd);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(ret)) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;queue %d: failed to map data\n&quot;</span>, <span class="built_in">queue</span>-&gt;idx);</span><br><span class="line">		<span class="keyword">if</span> (nvmet_tcp_has_inline_data(<span class="built_in">queue</span>-&gt;cmd))</span><br><span class="line">			nvmet_tcp_fatal_error(<span class="built_in">queue</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			nvmet_req_complete(req, ret);</span><br><span class="line">		ret = -EAGAIN;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*对上面申请的iov和sgl做映射，然后初始化cmd-&gt;recv_msg.msg_iter，</span></span><br><span class="line"><span class="comment">    	将状态变为NVMET_TCP_RECV_DATA，准备接收host端发送过来的数据，然后直接返回到nvmet_tcp_try_recv_one函数中去*/</span></span><br><span class="line">	<span class="keyword">if</span> (nvmet_tcp_need_data_in(<span class="built_in">queue</span>-&gt;cmd)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nvmet_tcp_has_inline_data(<span class="built_in">queue</span>-&gt;cmd)) &#123;</span><br><span class="line">			<span class="built_in">queue</span>-&gt;rcv_state = NVMET_TCP_RECV_DATA;</span><br><span class="line">			nvmet_tcp_map_pdu_iovec(<span class="built_in">queue</span>-&gt;cmd);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* send back R2T */</span></span><br><span class="line">		nvmet_tcp_queue_response(&amp;<span class="built_in">queue</span>-&gt;cmd-&gt;req);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nvmet_req_execute(&amp;<span class="built_in">queue</span>-&gt;cmd-&gt;req);</span><br><span class="line">out:</span><br><span class="line">	nvmet_prepare_receive_pdu(<span class="built_in">queue</span>);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nvmet-req-init"><a href="#nvmet-req-init" class="headerlink" title="nvmet_req_init"></a>nvmet_req_init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nvmet_req_init</span><span class="params">(struct nvmet_req *req, struct nvmet_cq *cq,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct nvmet_sq *sq, <span class="keyword">const</span> struct nvmet_fabrics_ops *ops)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 flags = req-&gt;cmd-&gt;common.flags;</span><br><span class="line">	u16 status;</span><br><span class="line"></span><br><span class="line">	req-&gt;cq = cq;</span><br><span class="line">	req-&gt;sq = sq;</span><br><span class="line">	req-&gt;ops = ops;</span><br><span class="line">	req-&gt;sg = <span class="literal">NULL</span>;</span><br><span class="line">	req-&gt;sg_cnt = <span class="number">0</span>;</span><br><span class="line">	req-&gt;transfer_len = <span class="number">0</span>;</span><br><span class="line">	req-&gt;cqe-&gt;status = <span class="number">0</span>;</span><br><span class="line">	req-&gt;cqe-&gt;sq_head = <span class="number">0</span>;</span><br><span class="line">	req-&gt;ns = <span class="literal">NULL</span>;</span><br><span class="line">	req-&gt;error_loc = NVMET_NO_ERROR_LOC;</span><br><span class="line">	req-&gt;error_slba = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* no support for fused commands yet */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(flags &amp; (NVME_CMD_FUSE_FIRST | NVME_CMD_FUSE_SECOND)) || req-&gt;cmd-&gt;common.opcode == nvme_admin_ndp_execute) &#123;</span><br><span class="line">		req-&gt;error_loc = offsetof(struct nvme_common_command, flags);</span><br><span class="line">		status = NVME_SC_INVALID_FIELD | NVME_SC_DNR;</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For fabrics, PSDT field shall describe metadata pointer (MPTR) that</span></span><br><span class="line"><span class="comment">	 * contains an address of a single contiguous physical buffer that is</span></span><br><span class="line"><span class="comment">	 * byte aligned.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely((flags &amp; NVME_CMD_SGL_ALL) != NVME_CMD_SGL_METABUF)) &#123;</span><br><span class="line">		req-&gt;error_loc = offsetof(struct nvme_common_command, flags);</span><br><span class="line">		status = NVME_SC_INVALID_FIELD | NVME_SC_DNR;</span><br><span class="line">		printk(<span class="string">&quot;For fabrics, PSDT field shall describe metadata pointer (MPTR) status=%d&quot;</span>,status);</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!req-&gt;sq-&gt;ctrl))&#123;</span><br><span class="line">		<span class="comment">/* will return an error for any Non-connect command: */</span></span><br><span class="line">		status = nvmet_parse_connect_cmd(req);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*IO命令进入，做相关初始化操作*/</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (likely(req-&gt;sq-&gt;qid != <span class="number">0</span>))&#123;</span><br><span class="line">		status = nvmet_parse_io_cmd(req);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nvme_is_fabrics(req-&gt;cmd))&#123;</span><br><span class="line">		status = nvmet_parse_fabrics_cmd(req);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (req-&gt;sq-&gt;ctrl-&gt;subsys-&gt;type == NVME_NQN_DISC)&#123;</span><br><span class="line">		status = nvmet_parse_discovery_cmd(req);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*admin命令进入，做相关初始化操作*/</span></span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		status = nvmet_parse_admin_cmd(req);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	trace_nvmet_req_init(req, req-&gt;cmd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!percpu_ref_tryget_live(&amp;sq-&gt;ref))) &#123;</span><br><span class="line">		status = NVME_SC_INVALID_FIELD | NVME_SC_DNR;</span><br><span class="line">		printk(<span class="string">&quot;unlikely(!percpu_ref_tryget_live(&amp;sq-&gt;ref)) status=%d&quot;</span>,status);</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sq-&gt;ctrl)</span><br><span class="line">		sq-&gt;ctrl-&gt;cmd_seen = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">	__nvmet_req_complete(req, status);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(nvmet_req_init);</span><br></pre></td></tr></table></figure>



<h3 id="nvmet-parse-io-cmd"><a href="#nvmet-parse-io-cmd" class="headerlink" title="nvmet_parse_io_cmd"></a>nvmet_parse_io_cmd</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u16 <span class="title">nvmet_parse_io_cmd</span><span class="params">(struct nvmet_req *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_command</span> *<span class="title">cmd</span> =</span> req-&gt;cmd;</span><br><span class="line">	u16 ret;</span><br><span class="line"></span><br><span class="line">	ret = nvmet_check_ctrl_status(req, cmd);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(ret))</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	<span class="comment">/*检查各种状态后，绑定执行函数*/</span></span><br><span class="line">	req-&gt;ns = nvmet_find_namespace(req-&gt;sq-&gt;ctrl, cmd-&gt;rw.nsid);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!req-&gt;ns)) &#123;</span><br><span class="line">		req-&gt;error_loc = offsetof(struct nvme_common_command, nsid);</span><br><span class="line">		<span class="keyword">return</span> NVME_SC_INVALID_NS | NVME_SC_DNR;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = nvmet_check_ana_state(req-&gt;port, req-&gt;ns);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(ret)) &#123;</span><br><span class="line">		req-&gt;error_loc = offsetof(struct nvme_common_command, nsid);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = nvmet_io_cmd_check_access(req);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(ret)) &#123;</span><br><span class="line">		req-&gt;error_loc = offsetof(struct nvme_common_command, nsid);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (req-&gt;ns-&gt;file)&#123;</span><br><span class="line">		<span class="keyword">return</span> nvmet_file_parse_io_cmd(req);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">/*Write操作进入这个函数绑定执行操作以及计算data_len*/</span></span><br><span class="line">		<span class="keyword">return</span> nvmet_bdev_parse_io_cmd(req);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nvmet-bdev-parse-io-cmd"><a href="#nvmet-bdev-parse-io-cmd" class="headerlink" title="nvmet_bdev_parse_io_cmd"></a>nvmet_bdev_parse_io_cmd</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u16 <span class="title">nvmet_bdev_parse_io_cmd</span><span class="params">(struct nvmet_req *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_command</span> *<span class="title">cmd</span> =</span> req-&gt;cmd;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd-&gt;common.opcode) &#123;</span><br><span class="line">	<span class="keyword">case</span> nvme_cmd_read:</span><br><span class="line">    <span class="comment">/*绑定request的执行函数，根据传输的参数length计算该request需要处理的数据长度*/</span></span><br><span class="line">	<span class="keyword">case</span> nvme_cmd_write:</span><br><span class="line">		req-&gt;execute = nvmet_bdev_execute_rw;</span><br><span class="line">		req-&gt;data_len = nvmet_rw_len(req);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> nvme_cmd_flush:</span><br><span class="line">		req-&gt;execute = nvmet_bdev_execute_flush;</span><br><span class="line">		req-&gt;data_len = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> nvme_cmd_dsm:</span><br><span class="line">		req-&gt;execute = nvmet_bdev_execute_dsm;</span><br><span class="line">		req-&gt;data_len = (le32_to_cpu(cmd-&gt;dsm.nr) + <span class="number">1</span>) *</span><br><span class="line">			<span class="keyword">sizeof</span>(struct nvme_dsm_range);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> nvme_cmd_write_zeroes:</span><br><span class="line">		req-&gt;execute = nvmet_bdev_execute_write_zeroes;</span><br><span class="line">		req-&gt;data_len = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		pr_err(<span class="string">&quot;unhandled cmd %d on qid %d\n&quot;</span>, cmd-&gt;common.opcode,</span><br><span class="line">		       req-&gt;sq-&gt;qid);</span><br><span class="line">		req-&gt;error_loc = offsetof(struct nvme_common_command, opcode);</span><br><span class="line">		<span class="keyword">return</span> NVME_SC_INVALID_OPCODE | NVME_SC_DNR;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nvmet-tcp-map-data"><a href="#nvmet-tcp-map-data" class="headerlink" title="nvmet_tcp_map_data"></a>nvmet_tcp_map_data</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nvmet_tcp_map_data</span><span class="params">(struct nvmet_tcp_cmd *cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk(<span class="string">&quot;nvmet_tcp_map_data&quot;</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_sgl_desc</span> *<span class="title">sgl</span> =</span> &amp;cmd-&gt;req.cmd-&gt;common.dptr.sgl;</span><br><span class="line">	u32 len = le32_to_cpu(sgl-&gt;length);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!cmd-&gt;req.data_len)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sgl-&gt;type == ((NVME_SGL_FMT_DATA_DESC &lt;&lt; <span class="number">4</span>) |</span><br><span class="line">			  NVME_SGL_FMT_OFFSET)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!nvme_is_write(cmd-&gt;req.cmd))</span><br><span class="line">			<span class="keyword">return</span> NVME_SC_INVALID_FIELD | NVME_SC_DNR;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (len &gt; cmd-&gt;req.port-&gt;inline_data_size)</span><br><span class="line">			<span class="keyword">return</span> NVME_SC_SGL_INVALID_OFFSET | NVME_SC_DNR;</span><br><span class="line">		cmd-&gt;pdu_len = len;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*这里transfer_len等于sgl-&gt;length*/</span></span><br><span class="line">	cmd-&gt;req.transfer_len += len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*申请sgl，准备好将数据放在这里*/</span></span><br><span class="line">	cmd-&gt;req.sg = sgl_alloc(len, GFP_KERNEL, &amp;cmd-&gt;req.sg_cnt);</span><br><span class="line">	<span class="keyword">if</span> (!cmd-&gt;req.sg)</span><br><span class="line">		<span class="keyword">return</span> NVME_SC_INTERNAL;</span><br><span class="line">	cmd-&gt;cur_sg = cmd-&gt;req.sg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*如果随着pdu一起过来的还有data，申请cmd-&gt;iov数组*/</span></span><br><span class="line">	<span class="keyword">if</span> (nvmet_tcp_has_data_in(cmd)) &#123;</span><br><span class="line">		cmd-&gt;iov = kmalloc_array(cmd-&gt;req.sg_cnt,</span><br><span class="line">				<span class="keyword">sizeof</span>(*cmd-&gt;iov), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!cmd-&gt;iov)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">	sgl_free(cmd-&gt;req.sg);</span><br><span class="line">	<span class="keyword">return</span> NVME_SC_INTERNAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nvmet-tcp-try-recv-data"><a href="#nvmet-tcp-try-recv-data" class="headerlink" title="nvmet_tcp_try_recv_data"></a>nvmet_tcp_try_recv_data</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nvmet_tcp_try_recv_data</span><span class="params">(struct nvmet_tcp_queue *<span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvmet_tcp_cmd</span>  *<span class="title">cmd</span> =</span> <span class="built_in">queue</span>-&gt;cmd;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*host端将非连续的page分次send，那么target端也要同步进行recv*/</span></span><br><span class="line">	<span class="keyword">while</span> (msg_data_left(&amp;cmd-&gt;recv_msg)) &#123;</span><br><span class="line">		ret = sock_recvmsg(cmd-&gt;<span class="built_in">queue</span>-&gt;sock, &amp;cmd-&gt;recv_msg,</span><br><span class="line">			cmd-&gt;recv_msg.msg_flags);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">		cmd-&gt;pdu_recv += ret;</span><br><span class="line">		cmd-&gt;rbytes_done += ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*解除SGL和iov的映射关系 此时，数据已经全部被接收*/</span></span><br><span class="line">	nvmet_tcp_unmap_pdu_iovec(cmd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(cmd-&gt;flags &amp; NVMET_TCP_F_INIT_FAILED) &amp;&amp;</span><br><span class="line">	    cmd-&gt;rbytes_done == cmd-&gt;req.transfer_len) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;data_digest) &#123;</span><br><span class="line">			nvmet_tcp_prep_recv_ddgst(cmd);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">/*执行之前绑定的处理函数，这里是nvmet_bdev_execute_rw*/</span></span><br><span class="line">		nvmet_req_execute(&amp;cmd-&gt;req);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nvmet_prepare_receive_pdu(<span class="built_in">queue</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nvmet-bdev-execute-rw"><a href="#nvmet-bdev-execute-rw" class="headerlink" title="nvmet_bdev_execute_rw"></a>nvmet_bdev_execute_rw</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nvmet_bdev_execute_rw</span><span class="params">(struct nvmet_req *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sg_cnt = req-&gt;sg_cnt;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bio</span> *<span class="title">bio</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> *<span class="title">sg</span>;</span></span><br><span class="line">	<span class="keyword">sector_t</span> sector;</span><br><span class="line">	<span class="keyword">int</span> op, op_flags = <span class="number">0</span>, i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!req-&gt;sg_cnt) &#123;</span><br><span class="line">		nvmet_req_complete(req, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置用于target端通过PCI接口下发sgl的op*/</span></span><br><span class="line">	<span class="keyword">if</span> (req-&gt;cmd-&gt;rw.opcode == nvme_cmd_write) &#123;</span><br><span class="line">		op = REQ_OP_WRITE;</span><br><span class="line">		op_flags = REQ_SYNC | REQ_IDLE;</span><br><span class="line">		<span class="keyword">if</span> (req-&gt;cmd-&gt;rw.control &amp; cpu_to_le16(NVME_RW_FUA))</span><br><span class="line">			op_flags |= REQ_FUA;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		op = REQ_OP_READ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (is_pci_p2pdma_page(sg_page(req-&gt;sg)))</span><br><span class="line">		op_flags |= REQ_NOMERGE;</span><br><span class="line"></span><br><span class="line">	sector = le64_to_cpu(req-&gt;cmd-&gt;rw.slba);</span><br><span class="line">	sector &lt;&lt;= (req-&gt;ns-&gt;blksize_shift - <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*初始化或者申请BIO*/</span></span><br><span class="line">	<span class="keyword">if</span> (req-&gt;data_len &lt;= NVMET_MAX_INLINE_DATA_LEN) &#123;</span><br><span class="line">		bio = &amp;req-&gt;b.inline_bio;</span><br><span class="line">		bio_init(bio, req-&gt;inline_bvec, ARRAY_SIZE(req-&gt;inline_bvec));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		bio = bio_alloc(GFP_KERNEL, min(sg_cnt, BIO_MAX_PAGES));</span><br><span class="line">	&#125;</span><br><span class="line">	bio_set_dev(bio, req-&gt;ns-&gt;bdev);</span><br><span class="line">	bio-&gt;bi_iter.bi_sector = sector;</span><br><span class="line">	bio-&gt;bi_private = req;</span><br><span class="line">	bio-&gt;bi_end_io = nvmet_bio_done;</span><br><span class="line">	bio_set_op_attrs(bio, op, op_flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*遍历所有的sgl，对可以进行合并的sgl合并到同一个BIO中，不连续的则申请新的BIO，将上一个BIO通过submit_bio下发*/</span></span><br><span class="line">	for_each_sg(req-&gt;sg, sg, req-&gt;sg_cnt, i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (bio_add_page(bio, sg_page(sg), sg-&gt;length, sg-&gt;offset)</span><br><span class="line">				!= sg-&gt;length) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">bio</span> *<span class="title">prev</span> =</span> bio;</span><br><span class="line"></span><br><span class="line">			bio = bio_alloc(GFP_KERNEL, min(sg_cnt, BIO_MAX_PAGES));</span><br><span class="line">			bio_set_dev(bio, req-&gt;ns-&gt;bdev);</span><br><span class="line">			bio-&gt;bi_iter.bi_sector = sector;</span><br><span class="line">			bio_set_op_attrs(bio, op, op_flags);</span><br><span class="line"></span><br><span class="line">			bio_chain(bio, prev);</span><br><span class="line">			submit_bio(prev);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sector += sg-&gt;length &gt;&gt; <span class="number">9</span>;</span><br><span class="line">		sg_cnt--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	submit_bio(bio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nvmet-bio-done"><a href="#nvmet-bio-done" class="headerlink" title="nvmet_bio_done"></a>nvmet_bio_done</h3><p>BIO全部下发结束后，触发bi_end_io，也就是nvmet_bio_done函数，函数一路到最后会触发nvmet_tcp_queue_response函数，表示该nvme命令处理完毕，需要回传结果了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nvmet_bio_done</span><span class="params">(struct bio *bio)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvmet_req</span> *<span class="title">req</span> =</span> bio-&gt;bi_private;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*调用绑定好的complete函数，准备cqe*/</span></span><br><span class="line">	nvmet_req_complete(req, blk_to_nvme_status(req, bio-&gt;bi_status));</span><br><span class="line">	<span class="keyword">if</span> (bio != &amp;req-&gt;b.inline_bio)</span><br><span class="line">		bio_put(bio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nvmet_req_complete</span><span class="params">(struct nvmet_req *req, u16 status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__nvmet_req_complete(req, status);</span><br><span class="line">	percpu_ref_put(&amp;req-&gt;sq-&gt;ref);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(nvmet_req_complete);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __nvmet_req_complete(struct nvmet_req *req, u16 status)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!req-&gt;sq-&gt;sqhd_disabled)</span><br><span class="line">		nvmet_update_sq_head(req);</span><br><span class="line">    <span class="comment">/*填充cqe，等待后续发送给host端*/</span></span><br><span class="line">	req-&gt;cqe-&gt;sq_id = cpu_to_le16(req-&gt;sq-&gt;qid);</span><br><span class="line">	req-&gt;cqe-&gt;command_id = req-&gt;cmd-&gt;common.command_id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(status))</span><br><span class="line">		nvmet_set_error(req, status);</span><br><span class="line"></span><br><span class="line">	trace_nvmet_req_complete(req);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (req-&gt;ns)</span><br><span class="line">		nvmet_put_namespace(req-&gt;ns);</span><br><span class="line">	req-&gt;ops-&gt;queue_response(req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nvmet_tcp_queue_response</span><span class="params">(struct nvmet_req *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvmet_tcp_cmd</span> *<span class="title">cmd</span> =</span></span><br><span class="line">		container_of(req, struct nvmet_tcp_cmd, req);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvmet_tcp_queue</span>	*<span class="title">queue</span> =</span> cmd-&gt;<span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">	llist_add(&amp;cmd-&gt;lentry, &amp;<span class="built_in">queue</span>-&gt;resp_list);</span><br><span class="line">    <span class="comment">/*触发新的io_work函数 发送cqe*/</span></span><br><span class="line">	queue_work_on(cmd-&gt;<span class="built_in">queue</span>-&gt;cpu, nvmet_tcp_wq, &amp;cmd-&gt;<span class="built_in">queue</span>-&gt;io_work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nvmet-tcp-try-send-one"><a href="#nvmet-tcp-try-send-one" class="headerlink" title="nvmet_tcp_try_send_one"></a>nvmet_tcp_try_send_one</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nvmet_tcp_try_send_one</span><span class="params">(struct nvmet_tcp_queue *<span class="built_in">queue</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">bool</span> last_in_batch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvmet_tcp_cmd</span> *<span class="title">cmd</span> =</span> <span class="built_in">queue</span>-&gt;snd_cmd;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*此时还没有构造要发送的cmd，所以进入fetch_cmd构造cmd*/</span></span><br><span class="line">	<span class="keyword">if</span> (!cmd || <span class="built_in">queue</span>-&gt;state == NVMET_TCP_Q_DISCONNECTING) &#123;</span><br><span class="line">		cmd = nvmet_tcp_fetch_cmd(<span class="built_in">queue</span>);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!cmd))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cmd-&gt;state == NVMET_TCP_SEND_DATA_PDU) &#123;</span><br><span class="line">		ret = nvmet_try_send_data_pdu(cmd);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> done_send;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cmd-&gt;state == NVMET_TCP_SEND_DATA) &#123;</span><br><span class="line">		ret = nvmet_try_send_data(cmd, last_in_batch);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> done_send;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cmd-&gt;state == NVMET_TCP_SEND_DDGST) &#123;</span><br><span class="line">		ret = nvmet_try_send_ddgst(cmd);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> done_send;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cmd-&gt;state == NVMET_TCP_SEND_R2T) &#123;</span><br><span class="line">		ret = nvmet_try_send_r2t(cmd, last_in_batch);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> done_send;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*构造完成后，进入nvmet_try_send_response函数，发送cqe*/</span></span><br><span class="line">	<span class="keyword">if</span> (cmd-&gt;state == NVMET_TCP_SEND_RESPONSE)</span><br><span class="line">		ret = nvmet_try_send_response(cmd, last_in_batch);</span><br><span class="line"></span><br><span class="line">done_send:</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ret == -EAGAIN)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct nvmet_tcp_cmd *<span class="title">nvmet_tcp_fetch_cmd</span><span class="params">(struct nvmet_tcp_queue *<span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*从response_send_list申请结构体*/</span></span><br><span class="line">	<span class="built_in">queue</span>-&gt;snd_cmd = list_first_entry_or_null(&amp;<span class="built_in">queue</span>-&gt;resp_send_list,</span><br><span class="line">				struct nvmet_tcp_cmd, entry);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">queue</span>-&gt;snd_cmd) &#123;</span><br><span class="line">        <span class="comment">/*如果无法申请说明list未初始化，初始化后重新申请*/</span></span><br><span class="line">		nvmet_tcp_process_resp_list(<span class="built_in">queue</span>);</span><br><span class="line">		<span class="built_in">queue</span>-&gt;snd_cmd =</span><br><span class="line">			list_first_entry_or_null(&amp;<span class="built_in">queue</span>-&gt;resp_send_list,</span><br><span class="line">					struct nvmet_tcp_cmd, entry);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!<span class="built_in">queue</span>-&gt;snd_cmd))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*queue的send_list状态变化*/</span></span><br><span class="line">	list_del_init(&amp;<span class="built_in">queue</span>-&gt;snd_cmd-&gt;entry);</span><br><span class="line">	<span class="built_in">queue</span>-&gt;send_list_len--;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nvmet_tcp_need_data_out(<span class="built_in">queue</span>-&gt;snd_cmd))</span><br><span class="line">		nvmet_setup_c2h_data_pdu(<span class="built_in">queue</span>-&gt;snd_cmd);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nvmet_tcp_need_data_in(<span class="built_in">queue</span>-&gt;snd_cmd))</span><br><span class="line">		nvmet_setup_r2t_pdu(<span class="built_in">queue</span>-&gt;snd_cmd);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        <span class="comment">/*由于是write命令，不需要数据，所以调用nvmet_setup_response_pdu函数构造response_pdu*/</span></span><br><span class="line">		nvmet_setup_response_pdu(<span class="built_in">queue</span>-&gt;snd_cmd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">queue</span>-&gt;snd_cmd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nvmet-setup-response-pdu"><a href="#nvmet-setup-response-pdu" class="headerlink" title="nvmet_setup_response_pdu"></a>nvmet_setup_response_pdu</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nvmet_setup_response_pdu</span><span class="params">(struct nvmet_tcp_cmd *cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_tcp_rsp_pdu</span> *<span class="title">pdu</span> =</span> cmd-&gt;rsp_pdu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvmet_tcp_queue</span> *<span class="title">queue</span> =</span> cmd-&gt;<span class="built_in">queue</span>;</span><br><span class="line">	u8 hdgst = nvmet_tcp_hdgst_len(cmd-&gt;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">	cmd-&gt;offset = <span class="number">0</span>;</span><br><span class="line">	cmd-&gt;state = NVMET_TCP_SEND_RESPONSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*初始化pdu*/</span></span><br><span class="line">	pdu-&gt;hdr.type = nvme_tcp_rsp;</span><br><span class="line">	pdu-&gt;hdr.flags = <span class="number">0</span>;</span><br><span class="line">	pdu-&gt;hdr.hlen = <span class="keyword">sizeof</span>(*pdu);</span><br><span class="line">	pdu-&gt;hdr.pdo = <span class="number">0</span>;</span><br><span class="line">	pdu-&gt;hdr.plen = cpu_to_le32(pdu-&gt;hdr.hlen + hdgst);</span><br><span class="line">	<span class="keyword">if</span> (cmd-&gt;<span class="built_in">queue</span>-&gt;hdr_digest) &#123;</span><br><span class="line">		pdu-&gt;hdr.flags |= NVME_TCP_F_HDGST;</span><br><span class="line">		nvmet_tcp_hdgst(<span class="built_in">queue</span>-&gt;snd_hash, pdu, <span class="keyword">sizeof</span>(*pdu));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nvmet_try_send_response</span><span class="params">(struct nvmet_tcp_cmd *cmd,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">bool</span> last_in_batch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 hdgst = nvmet_tcp_hdgst_len(cmd-&gt;<span class="built_in">queue</span>);</span><br><span class="line">	<span class="keyword">int</span> left = <span class="keyword">sizeof</span>(*cmd-&gt;rsp_pdu) - cmd-&gt;offset + hdgst;</span><br><span class="line">	<span class="keyword">int</span> flags = MSG_DONTWAIT;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!last_in_batch &amp;&amp; cmd-&gt;<span class="built_in">queue</span>-&gt;send_list_len)</span><br><span class="line">		flags |= MSG_MORE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		flags |= MSG_EOR;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*发送response_pdu给host端*/</span></span><br><span class="line">	ret = kernel_sendpage(cmd-&gt;<span class="built_in">queue</span>-&gt;sock, virt_to_page(cmd-&gt;rsp_pdu),</span><br><span class="line">		offset_in_page(cmd-&gt;rsp_pdu) + cmd-&gt;offset, left, flags);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	cmd-&gt;offset += ret;</span><br><span class="line">	left -= ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (left)</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">	kfree(cmd-&gt;iov);</span><br><span class="line">	sgl_free(cmd-&gt;req.sg);</span><br><span class="line">	cmd-&gt;<span class="built_in">queue</span>-&gt;snd_cmd = <span class="literal">NULL</span>;</span><br><span class="line">	nvmet_tcp_put_cmd(cmd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>至此，target端的工作结束，转回host端看host端try_recv的执行流程</p>
<h3 id="host端-1"><a href="#host端-1" class="headerlink" title="host端"></a>host端</h3><h3 id="nvme-tcp-try-recv"><a href="#nvme-tcp-try-recv" class="headerlink" title="nvme_tcp_try_recv"></a>nvme_tcp_try_recv</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nvme_tcp_try_recv</span><span class="params">(struct nvme_tcp_queue *<span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span> =</span> <span class="built_in">queue</span>-&gt;sock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line">	<span class="keyword">read_descriptor_t</span> rd_desc;</span><br><span class="line">	<span class="keyword">int</span> consumed;</span><br><span class="line"></span><br><span class="line">	rd_desc.arg.data = <span class="built_in">queue</span>;</span><br><span class="line">	rd_desc.count = <span class="number">1</span>;</span><br><span class="line">	lock_sock(sk);</span><br><span class="line">	<span class="built_in">queue</span>-&gt;nr_cqe = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*调用nvme_tcp_recv_skb对接收到的数据进行处理*/</span></span><br><span class="line">	consumed = sock-&gt;ops-&gt;read_sock(sk, &amp;rd_desc, nvme_tcp_recv_skb);</span><br><span class="line">	release_sock(sk);</span><br><span class="line">	<span class="keyword">return</span> consumed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nvme_tcp_recv_skb</span><span class="params">(<span class="keyword">read_descriptor_t</span> *desc, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">			     <span class="keyword">unsigned</span> <span class="keyword">int</span> offset, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_tcp_queue</span> *<span class="title">queue</span> =</span> desc-&gt;arg.data;</span><br><span class="line">	<span class="keyword">size_t</span> consumed = len;</span><br><span class="line">	<span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (len) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (nvme_tcp_recv_state(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">		<span class="keyword">case</span> NVME_TCP_RECV_PDU:</span><br><span class="line">            <span class="comment">/*进入分支，调用nvme_tcp_recv_pdu函数*/</span></span><br><span class="line">			result = nvme_tcp_recv_pdu(<span class="built_in">queue</span>, skb, &amp;offset, &amp;len);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> NVME_TCP_RECV_DATA:</span><br><span class="line">			result = nvme_tcp_recv_data(<span class="built_in">queue</span>, skb, &amp;offset, &amp;len);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> NVME_TCP_RECV_DDGST:</span><br><span class="line">			result = nvme_tcp_recv_ddgst(<span class="built_in">queue</span>, skb, &amp;offset, &amp;len);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			result = -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (result) &#123;</span><br><span class="line">			dev_err(<span class="built_in">queue</span>-&gt;ctrl-&gt;ctrl.device,</span><br><span class="line">				<span class="string">&quot;receive failed:  %d\n&quot;</span>, result);</span><br><span class="line">			<span class="built_in">queue</span>-&gt;rd_enabled = <span class="literal">false</span>;</span><br><span class="line">			nvme_tcp_error_recovery(&amp;<span class="built_in">queue</span>-&gt;ctrl-&gt;ctrl);</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> consumed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nvme_tcp_recv_pdu</span><span class="params">(struct nvme_tcp_queue *<span class="built_in">queue</span>, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">unsigned</span> <span class="keyword">int</span> *offset, <span class="keyword">size_t</span> *len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_tcp_hdr</span> *<span class="title">hdr</span>;</span></span><br><span class="line">	<span class="keyword">char</span> *pdu = <span class="built_in">queue</span>-&gt;pdu;</span><br><span class="line">	<span class="keyword">size_t</span> rcv_len = <span class="keyword">min_t</span>(<span class="keyword">size_t</span>, *len, <span class="built_in">queue</span>-&gt;pdu_remaining);</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*将接收到的pdu数据写入queue的pdu中*/</span></span><br><span class="line">	ret = skb_copy_bits(skb, *offset,</span><br><span class="line">		&amp;pdu[<span class="built_in">queue</span>-&gt;pdu_offset], rcv_len);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(ret))</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">queue</span>-&gt;pdu_remaining -= rcv_len;</span><br><span class="line">	<span class="built_in">queue</span>-&gt;pdu_offset += rcv_len;</span><br><span class="line">	*offset += rcv_len;</span><br><span class="line">	*len -= rcv_len;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;pdu_remaining)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hdr = <span class="built_in">queue</span>-&gt;pdu;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;hdr_digest) &#123;</span><br><span class="line">		ret = nvme_tcp_verify_hdgst(<span class="built_in">queue</span>, <span class="built_in">queue</span>-&gt;pdu, hdr-&gt;hlen);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(ret))</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;data_digest) &#123;</span><br><span class="line">		ret = nvme_tcp_check_ddgst(<span class="built_in">queue</span>, <span class="built_in">queue</span>-&gt;pdu);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(ret))</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (hdr-&gt;type) &#123;</span><br><span class="line">	<span class="keyword">case</span> nvme_tcp_c2h_data:</span><br><span class="line">		<span class="keyword">return</span> nvme_tcp_handle_c2h_data(<span class="built_in">queue</span>, (<span class="keyword">void</span> *)<span class="built_in">queue</span>-&gt;pdu);</span><br><span class="line">	<span class="keyword">case</span> nvme_tcp_rsp:</span><br><span class="line">        <span class="comment">/*write命令进入一下分支，初始化recv ctx，准备处理cqe*/</span></span><br><span class="line">		nvme_tcp_init_recv_ctx(<span class="built_in">queue</span>);</span><br><span class="line">		<span class="keyword">return</span> nvme_tcp_handle_comp(<span class="built_in">queue</span>, (<span class="keyword">void</span> *)<span class="built_in">queue</span>-&gt;pdu);</span><br><span class="line">	<span class="keyword">case</span> nvme_tcp_r2t:</span><br><span class="line">		nvme_tcp_init_recv_ctx(<span class="built_in">queue</span>);</span><br><span class="line">		<span class="keyword">return</span> nvme_tcp_handle_r2t(<span class="built_in">queue</span>, (<span class="keyword">void</span> *)<span class="built_in">queue</span>-&gt;pdu);</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		dev_err(<span class="built_in">queue</span>-&gt;ctrl-&gt;ctrl.device,</span><br><span class="line">			<span class="string">&quot;unsupported pdu type (%d)\n&quot;</span>, hdr-&gt;type);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nvme_tcp_init_recv_ctx</span><span class="params">(struct nvme_tcp_queue *<span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>-&gt;pdu_remaining = <span class="keyword">sizeof</span>(struct nvme_tcp_rsp_pdu) +</span><br><span class="line">				nvme_tcp_hdgst_len(<span class="built_in">queue</span>);</span><br><span class="line">	<span class="built_in">queue</span>-&gt;pdu_offset = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue</span>-&gt;data_remaining = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">queue</span>-&gt;ddgst_remaining = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nvme_tcp_handle_comp</span><span class="params">(struct nvme_tcp_queue *<span class="built_in">queue</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct nvme_tcp_rsp_pdu *pdu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_completion</span> *<span class="title">cqe</span> =</span> &amp;pdu-&gt;cqe;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * AEN requests are special as they don&#x27;t time out and can</span></span><br><span class="line"><span class="comment">	 * survive any kind of queue freeze and often don&#x27;t respond to</span></span><br><span class="line"><span class="comment">	 * aborts.  We don&#x27;t even bother to allocate a struct request</span></span><br><span class="line"><span class="comment">	 * for them but rather special case them here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(nvme_tcp_queue_id(<span class="built_in">queue</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">	    cqe-&gt;command_id &gt;= NVME_AQ_BLK_MQ_DEPTH))</span><br><span class="line">		nvme_complete_async_event(&amp;<span class="built_in">queue</span>-&gt;ctrl-&gt;ctrl, cqe-&gt;status,</span><br><span class="line">				&amp;cqe-&gt;result);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        <span class="comment">/*处理接受到的cqe*/</span></span><br><span class="line">		ret = nvme_tcp_process_nvme_cqe(<span class="built_in">queue</span>, cqe);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nvme-tcp-process-nvme-cqe"><a href="#nvme-tcp-process-nvme-cqe" class="headerlink" title="nvme_tcp_process_nvme_cqe"></a>nvme_tcp_process_nvme_cqe</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nvme_tcp_process_nvme_cqe</span><span class="params">(struct nvme_tcp_queue *<span class="built_in">queue</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct nvme_completion *cqe)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	rq = blk_mq_tag_to_rq(nvme_tcp_tagset(<span class="built_in">queue</span>), cqe-&gt;command_id);</span><br><span class="line">	<span class="keyword">if</span> (!rq) &#123;</span><br><span class="line">		dev_err(<span class="built_in">queue</span>-&gt;ctrl-&gt;ctrl.device,</span><br><span class="line">			<span class="string">&quot;queue %d tag 0x%x not found\n&quot;</span>,</span><br><span class="line">			nvme_tcp_queue_id(<span class="built_in">queue</span>), cqe-&gt;command_id);</span><br><span class="line">		nvme_tcp_error_recovery(&amp;<span class="built_in">queue</span>-&gt;ctrl-&gt;ctrl);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nvme_end_request(rq, cqe-&gt;status, cqe-&gt;result);</span><br><span class="line">	<span class="built_in">queue</span>-&gt;nr_cqe++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">nvme_end_request</span><span class="params">(struct request *req, __le16 status,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">union</span> nvme_result result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nvme_request</span> *<span class="title">rq</span> =</span> nvme_req(req);</span><br><span class="line"></span><br><span class="line">	rq-&gt;status = le16_to_cpu(status) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	rq-&gt;result = result;</span><br><span class="line">	<span class="comment">/* inject error when permitted by fault injection framework */</span></span><br><span class="line">	nvme_should_fail(req);</span><br><span class="line">    <span class="comment">/*执行TCP queue绑定好的complete函数*/</span></span><br><span class="line">	blk_mq_complete_request(req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nvme_complete_rq</span><span class="params">(struct request *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">blk_status_t</span> status = nvme_error_status(nvme_req(req)-&gt;status);</span><br><span class="line"></span><br><span class="line">	trace_nvme_complete_rq(req);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nvme_req(req)-&gt;ctrl-&gt;kas)</span><br><span class="line">		nvme_req(req)-&gt;ctrl-&gt;comp_seen = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(status != BLK_STS_OK &amp;&amp; nvme_req_needs_retry(req))) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((req-&gt;cmd_flags &amp; REQ_NVME_MPATH) &amp;&amp; nvme_failover_req(req))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!blk_queue_dying(req-&gt;q)) &#123;</span><br><span class="line">			nvme_retry_req(req);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nvme_trace_bio_complete(req, status);</span><br><span class="line">    <span class="comment">/*结束request命令*/</span></span><br><span class="line">	blk_mq_end_request(req, status);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(nvme_complete_rq);</span><br></pre></td></tr></table></figure>

<p>返回到最初的nvme_user_cmd函数中</p>
<h3 id="nvme-passthru-end"><a href="#nvme-passthru-end" class="headerlink" title="nvme_passthru_end"></a>nvme_passthru_end</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nvme_passthru_end</span><span class="params">(struct nvme_ctrl *ctrl, u32 effects)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Revalidate LBA changes prior to unfreezing. This is necessary to</span></span><br><span class="line"><span class="comment">	 * prevent memory corruption if a logical block size was changed by</span></span><br><span class="line"><span class="comment">	 * this command.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (effects &amp; NVME_CMD_EFFECTS_LBCC)</span><br><span class="line">		nvme_update_formats(ctrl);</span><br><span class="line">	<span class="keyword">if</span> (effects &amp; (NVME_CMD_EFFECTS_LBCC | NVME_CMD_EFFECTS_CSE_MASK)) &#123;</span><br><span class="line">		nvme_unfreeze(ctrl);</span><br><span class="line">		nvme_mpath_unfreeze(ctrl-&gt;subsys);</span><br><span class="line">		mutex_unlock(&amp;ctrl-&gt;subsys-&gt;lock);</span><br><span class="line">		nvme_remove_invalid_namespaces(ctrl, NVME_NSID_ALL);</span><br><span class="line">		mutex_unlock(&amp;ctrl-&gt;scan_lock);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (effects &amp; NVME_CMD_EFFECTS_CCC)</span><br><span class="line">		nvme_init_identify(ctrl);</span><br><span class="line">	<span class="keyword">if</span> (effects &amp; (NVME_CMD_EFFECTS_NIC | NVME_CMD_EFFECTS_NCC))</span><br><span class="line">		nvme_queue_scan(ctrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>至此一条ioctl write命令结束</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/NVMe-over-TCP/" rel="tag"><i class="fa fa-tag"></i> NVMe over TCP</a>
              <a href="/tags/femu/" rel="tag"><i class="fa fa-tag"></i> femu</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/12/22/femu%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E7%BD%91%E5%8D%A1%E6%8B%A5%E6%9C%89%E7%8B%AC%E7%AB%8BIP/" rel="prev" title="femu使用虚拟网卡拥有独立IP">
      <i class="fa fa-chevron-left"></i> femu使用虚拟网卡拥有独立IP
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%8E%AF%E5%A2%83"><span class="nav-text">1. 环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%80%E4%BA%9B%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-text">2. 一些前置知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-host%E7%AB%AF%E4%B8%8Etarget%E7%AB%AFIO%E8%B0%83%E7%94%A8%E6%A0%88"><span class="nav-text">3. host端与target端IO调用栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Write%E5%91%BD%E4%BB%A4%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="nav-text">4. Write命令函数调用关系图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Read%E5%91%BD%E4%BB%A4%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="nav-text">5. Read命令函数调用关系图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%87%BD%E6%95%B0%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90"><span class="nav-text">6. 函数具体分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#host%E7%AB%AF"><span class="nav-text">host端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvme-ioctl"><span class="nav-text">nvme_ioctl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvme-user-cmd"><span class="nav-text">nvme_user_cmd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvme-submit-user-cmd"><span class="nav-text">nvme_submit_user_cmd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvme-tcp-queue-rq"><span class="nav-text">nvme_tcp_queue_rq</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvme-tcp-setup-cmd-pdu"><span class="nav-text">nvme_tcp_setup_cmd_pdu</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvme-tcp-queue-request"><span class="nav-text">nvme_tcp_queue_request</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvme-tcp-io-work"><span class="nav-text">nvme_tcp_io_work</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvme-tcp-try-send"><span class="nav-text">nvme_tcp_try_send</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvme-tcp-try-send-cmd-pdu"><span class="nav-text">nvme_tcp_try_send_cmd_pdu</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvme-tcp-try-send-data"><span class="nav-text">nvme_tcp_try_send_data</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#target%E7%AB%AF"><span class="nav-text">target端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvmet-tcp-io-work"><span class="nav-text">nvmet_tcp_io_work</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvmet-tcp-try-recv"><span class="nav-text">nvmet_tcp_try_recv</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvmet-tcp-try-recv-one"><span class="nav-text">nvmet_tcp_try_recv_one</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvmet-tcp-try-recv-pdu"><span class="nav-text">nvmet_tcp_try_recv_pdu</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvmet-tcp-done-recv-pdu"><span class="nav-text">nvmet_tcp_done_recv_pdu</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvmet-req-init"><span class="nav-text">nvmet_req_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvmet-parse-io-cmd"><span class="nav-text">nvmet_parse_io_cmd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvmet-bdev-parse-io-cmd"><span class="nav-text">nvmet_bdev_parse_io_cmd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvmet-tcp-map-data"><span class="nav-text">nvmet_tcp_map_data</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvmet-tcp-try-recv-data"><span class="nav-text">nvmet_tcp_try_recv_data</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvmet-bdev-execute-rw"><span class="nav-text">nvmet_bdev_execute_rw</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvmet-bio-done"><span class="nav-text">nvmet_bio_done</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvmet-tcp-try-send-one"><span class="nav-text">nvmet_tcp_try_send_one</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvmet-setup-response-pdu"><span class="nav-text">nvmet_setup_response_pdu</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#host%E7%AB%AF-1"><span class="nav-text">host端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvme-tcp-try-recv"><span class="nav-text">nvme_tcp_try_recv</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvme-tcp-process-nvme-cqe"><span class="nav-text">nvme_tcp_process_nvme_cqe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvme-passthru-end"><span class="nav-text">nvme_passthru_end</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="freedomhust"
      src="/images/freedomhust.jpg">
  <p class="site-author-name" itemprop="name">freedomhust</p>
  <div class="site-description" itemprop="description">个人技术总结</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/freedomhust" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;freedomhust" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">freedomhust</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  
  <!--页面点击小桃心-->
  
     <canvas class="firework" style="position:fixed;left:0;top:0;z-index:99999999;pointer-events:none;"></canvas>
    <script type="text/javascript" src="/js/firework.js"></script>
  
  
</body>
</html>


